<!DOCTYPE html>
<html lang="en" class="Internet-Draft">
<head>
<meta charset="utf-8">
<meta content="Common,Latin" name="scripts">
<meta content="initial-scale=1.0" name="viewport">
<title>Self-Clocked Rate Adaptation for Multimedia</title>
<meta content="Ingemar Johansson" name="author">
<meta content="Magnus Westerlund" name="author">
<meta content="
       This memo describes Self-Clocked Rate Adaptation for Multimedia version 2
(SCReAMv2), an update to SCReAM congestion control for media streams such as RTP
 . SCReAMv2 compromised several algorithm simplifications and adds
support for L4S. The algorithm supports handling of multiple media streams,
typical use cases are streaming for remote control, ARand 3D VR googles.
This specification obsoletes RFC 8298. 
    " name="description">
<meta content="xml2rfc 3.25.0" name="generator">
<meta content="draft-johansson-ccwg-rfc8298bis-screamv2-latest" name="ietf.draft">
<!-- Generator version information:
  xml2rfc 3.25.0
    Python 3.12.7
    ConfigArgParse 1.7
    google-i18n-address 3.1.1
    intervaltree 3.1.0
    Jinja2 3.1.4
    lxml 5.3.0
    platformdirs 4.3.6
    pycountry 22.3.5
    PyYAML 6.0.1
    requests 2.32.3
    setuptools 70.3.0
    wcwidth 0.2.13
-->
<link href="draft-johansson-ccwg-rfc8298bis-screamv2.xml" rel="alternate" type="application/rfc+xml">
<link href="#copyright" rel="license">
<style type="text/css">@font-face {
  font-family: 'Lora';
  font-style: italic;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Italic'), local('Lora-Italic'), url('https://martinthomson.github.io/rfc-css/fonts/lora-italic-cyrillic-ext.woff2') format('woff2');
  unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
}
@font-face {
  font-family: 'Lora';
  font-style: italic;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Italic'), local('Lora-Italic'), url('https://martinthomson.github.io/rfc-css/fonts/lora-italic-cyrillic-ext.woff2') format('woff2');
  unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
}
@font-face {
  font-family: 'Lora';
  font-style: italic;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Italic'), local('Lora-Italic'), url('https://martinthomson.github.io/rfc-css/fonts/lora-italic-vietnamese.woff2') format('woff2');
  unicode-range: U+0102-0103, U+0110-0111, U+1EA0-1EF9, U+20AB;
}
@font-face {
  font-family: 'Lora';
  font-style: italic;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Italic'), local('Lora-Italic'), url('https://martinthomson.github.io/rfc-css/fonts/lora-italic-latin-ext.woff2') format('woff2');
  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
}

@font-face {
  font-family: 'Lora';
  font-style: italic;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Italic'), local('Lora-Italic'), url('https://martinthomson.github.io/rfc-css/fonts/lora-italic-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Regular'), local('Lora-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/lora-regular-cyrillic-ext.woff2') format('woff2');
  unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Regular'), local('Lora-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/lora-regular-cyrillic.woff2') format('woff2');
  unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Regular'), local('Lora-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/lora-regular-vietnamese.woff2') format('woff2');
  unicode-range: U+0102-0103, U+0110-0111, U+1EA0-1EF9, U+20AB;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Regular'), local('Lora-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/lora-regular-latin-ext.woff2') format('woff2');
  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Lora Regular'), local('Lora-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/lora-regular-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}

@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: local('Lora Bold'), local('Lora-Bold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-bold-cyrillic-ext.woff2') format('woff2');
  unicode-range: U+0460-052F, U+1C80-1C88, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: local('Lora Bold'), local('Lora-Bold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-bold-cyrillic.woff2') format('woff2');
  unicode-range: U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: local('Lora Bold'), local('Lora-Bold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-bold-vietnamese.woff2') format('woff2');
  unicode-range: U+0102-0103, U+0110-0111, U+1EA0-1EF9, U+20AB;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: local('Lora Bold'), local('Lora-Bold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-bold-latin-ext.woff2') format('woff2');
  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 700;
  font-display: swap;
  src: local('Lora Bold'), local('Lora-Bold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-bold-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
@font-face {
  font-family: 'Lora';
  font-style: normal;
  font-weight: 600;
  font-display: swap;
  src: local('Lora SemiBold'), local('Lora-SemiBold'), url('https://martinthomson.github.io/rfc-css/fonts/lora-semibold-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}

@font-face {
  font-family: 'Oxygen Mono';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Oxygen Mono'), local('OxygenMono-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/oxygenmono-regular-latin-ext.woff2') format('woff2');
  unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
@font-face {
  font-family: 'Oxygen Mono';
  font-style: normal;
  font-weight: 400;
  font-display: swap;
  src: local('Oxygen Mono'), local('OxygenMono-Regular'), url('https://martinthomson.github.io/rfc-css/fonts/oxygenmono-regular-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}

@font-face {
  font-family: 'Sofia Sans Semi Condensed';
  font-style: italic;
  font-weight: 1 1000;
  src: url('https://martinthomson.github.io/rfc-css/fonts/sofiasanssemicondensed-italic-cyrillic-ext.woff2') format('woff2');
  unicode-range: U+0460-052F, U+1C80-1C8A, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
}
@font-face {
  font-family: 'Sofia Sans Semi Condensed';
  font-style: italic;
  font-weight: 1 1000;
  src: url('https://martinthomson.github.io/rfc-css/fonts/sofiasanssemicondensed-italic-cyrillic.woff2') format('woff2');
  unicode-range: U+0301, U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
}
@font-face {
  font-family: 'Sofia Sans Semi Condensed';
  font-style: italic;
  font-weight: 1 1000;
  src: url('https://martinthomson.github.io/rfc-css/fonts/sofiasanssemicondensed-italic-greek.woff2') format('woff2');
  unicode-range: U+0370-0377, U+037A-037F, U+0384-038A, U+038C, U+038E-03A1, U+03A3-03FF;
}
@font-face {
  font-family: 'Sofia Sans Semi Condensed';
  font-style: italic;
  font-weight: 1 1000;
  src: url('https://martinthomson.github.io/rfc-css/fonts/sofiasanssemicondensed-italic-latin-ext.woff2') format('woff2');
  unicode-range: U+0100-02BA, U+02BD-02C5, U+02C7-02CC, U+02CE-02D7, U+02DD-02FF, U+0304, U+0308, U+0329, U+1D00-1DBF, U+1E00-1E9F, U+1EF2-1EFF, U+2020, U+20A0-20AB, U+20AD-20C0, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
@font-face {
  font-family: 'Sofia Sans Semi Condensed';
  font-style: italic;
  font-weight: 1 1000;
  src: url('https://martinthomson.github.io/rfc-css/fonts/sofiasanssemicondensed-italic-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}
@font-face {
  font-family: 'Sofia Sans Semi Condensed';
  font-style: normal;
  font-weight: 1 1000;
  src: url('https://martinthomson.github.io/rfc-css/fonts/sofiasanssemicondensed-regular-cyrillic-ext.woff2') format('woff2');
  unicode-range: U+0460-052F, U+1C80-1C8A, U+20B4, U+2DE0-2DFF, U+A640-A69F, U+FE2E-FE2F;
}
@font-face {
  font-family: 'Sofia Sans Semi Condensed';
  font-style: normal;
  font-weight: 1 1000;
  src: url('https://martinthomson.github.io/rfc-css/fonts/sofiasanssemicondensed-regular-cyrillic.woff2') format('woff2');
  unicode-range: U+0301, U+0400-045F, U+0490-0491, U+04B0-04B1, U+2116;
}
@font-face {
  font-family: 'Sofia Sans Semi Condensed';
  font-style: normal;
  font-weight: 1 1000;
  src: url('https://martinthomson.github.io/rfc-css/fonts/sofiasanssemicondensed-regular-greek.woff2') format('woff2');
  unicode-range: U+0370-0377, U+037A-037F, U+0384-038A, U+038C, U+038E-03A1, U+03A3-03FF;
}
@font-face {
  font-family: 'Sofia Sans Semi Condensed';
  font-style: normal;
  font-weight: 1 1000;
  src: url('https://martinthomson.github.io/rfc-css/fonts/sofiasanssemicondensed-regular-latin-ext.woff2') format('woff2');
  unicode-range: U+0100-02BA, U+02BD-02C5, U+02C7-02CC, U+02CE-02D7, U+02DD-02FF, U+0304, U+0308, U+0329, U+1D00-1DBF, U+1E00-1E9F, U+1EF2-1EFF, U+2020, U+20A0-20AB, U+20AD-20C0, U+2113, U+2C60-2C7F, U+A720-A7FF;
}
@font-face {
  font-family: 'Sofia Sans Semi Condensed';
  font-style: normal;
  font-weight: 1 1000;
  src: url('https://martinthomson.github.io/rfc-css/fonts/sofiasanssemicondensed-regular-latin.woff2') format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
}

:root {
  color-scheme: light dark;
  --background-color: #fff;
  --text-color: #222;
  --title-color: #191919;
  --link-color: #2a6496;
  --highlight-color: #f9f9f9;
  --line-color: #eee;
  --pilcrow-weak: #ddd;
  --pilcrow-strong: #bbb;
  --small-font-size: 14.5px;
  --font-mono: 'Oxygen Mono', monospace;
  --font-title: "Sofia Sans Semi Condensed", sans-serif;
  scrollbar-color: #bbb #eee;
}
body {
  max-width: 600px;
  margin: 75px auto;
  padding: 0 5px;
  color: var(--text-color);
  background-color: var(--background-color);
  font: 16px/22px "Lora", serif;
  scroll-behavior: smooth;
}

.ears {
  display: none;
}

/* headings */
section {
  clear: both;
}
.section-number {
  padding-right: 0.5em;
}
h1, h2, h3, h4, h5, h6 {
  font-family: var(--font-title);
  font-weight: 680;
  margin: 0.8em 0 0.3em;
  font-size-adjust: 0.5;
  color: var(--title-color);
}
h1#title {
  font-size: 32px;
  line-height: 40px;
  clear: both;
}
h1#title, h1#rfcnum {
  margin: 1.5em 0 0.2em;
}
h1#rfcnum + h1#title {
  margin: 0.2em 0;
}

h1, h2, h3 {
  font-size: 22px;
  line-height: 27px;
}
h4, h5, h6 {
  font-size: 20px;
  line-height: 24px;
}

/* general structure */
.author {
  padding-bottom: 0.3em;
  vertical-align: top;
}
#abstract+p {
  font-size: 18px;
  line-height: 24px;
}
#abstract+p code, #abstract+p samp, #abstract+p tt {
  font-size: 16px;
  line-height: 0;
}

p {
  padding: 0;
  margin: 0.5em 0;
  text-align: left;
}
div {
  margin: 0;
}
.alignRight.art-text {
  background-color: var(--highlight-color);
  border: 1px solid var(--line-color);
  border-radius: 3px;
  padding: 0.5em 1em 0;
  margin-bottom: 0.5em;
}
.alignRight.art-text pre {
  padding: 0;
  width: auto;
}
.alignRight {
  margin: 1em 0;
}
.alignRight > *:first-child {
  border: none;
  margin: 0;
  float: right;
  clear: both;
}
.alignRight > *:nth-child(2) {
  clear: both;
  display: block;
  border: none;
}
svg {
  display: block;
}
/* font-family isn't space-separated, but =~ will have to do */
svg[font-family~="monospace" i], svg [font-family~="monospace" i] {
  font-family: var(--font-mono);
}
.alignCenter.art-text {
  background-color: var(--highlight-color);
  border: 1px solid var(--line-color);
  border-radius: 3px;
  padding: 0.5em 1em 0;
  margin-bottom: 0.5em;
}
.alignCenter.art-text pre {
  padding: 0;
  width: auto;
}
.alignCenter {
  margin: 1em 0;
}
.alignCenter > *:first-child {
  border: none;
  /* this isn't optimal, but it's an existence proof.  PrinceXML doesn't
     support flexbox yet.
  */
  display: table;
  margin: 0 auto;
}

/* lists */
ol, ul {
  padding: 0;
  margin: 0 0 0.5em 2em;
  & :is(ol, ul) {
    margin-left: 1em;
  }
}
li {
  margin: 0 0 0.25em 0;
}
ul.empty, .ulEmpty {
  list-style-type: none;
  & li {
    margin-top: 0.5em;
  }
}
:is(ul, ol).compact, .ulCompact, .olCompact {
  margin: 0 0 0 2em;
  & li {
    margin: 0;
    & :first-child { margin-top: 0; }
    & :last-child { margin-bottom: 0; }
  }
}

/* definition lists */
dl {
  clear: left;
  --indent: 3ch;
  /* --indent: attr(indent ch); not supported in any browser, but we can dream */
  &.olPercent {
    --indent: 5ch;
    & > dt {
      min-width: calc(var(--indent) - 2ch);
    }
  }
  &.olPercent > dt {
    float: none;
  }

  dl > dd > & {
    margin-top: 0.5em;
    margin-bottom: 0;
  }
}
dl > dt {
  float: left;
  margin-right: 2ch;
  min-width: 8ch;
}
dl > dd {
  margin-bottom: .8em;
  margin-left: var(--indent) !important; /* stupid element overrides */
  min-height: 2ex;
}
:is(dl.compact, .dlCompact) > dd {
  margin-bottom: 0;
  & > :is(:first-child, .break:first-child + *) {
    margin-top: 0;
  }
  & > :is(:last-child) {
    margin-bottom: 0;
  }
}
:is(dd, span).break {
  display: none;
}

/* links */
a, a[href].selfRef:hover {
  text-decoration: none;
}
a[href] {
  color: var(--link-color);
}
a[href].selfRef, .iref + a[href].internal {
  color: var(--text-color);
}
a[href]:hover {
  text-decoration: underline;
}
a[href].selfRef:hover {
  background-color: var(--highlight-color);
}
a.xref:is(.cite, .auto), :is(#status-of-memo, #copyright) a {
  white-space: nowrap;
}

/* Figures */
tt, code, pre {
  background-color: var(--highlight-color);
  font: 14px/22px var(--font-mono);
}
tt, code {
  /* changing the font for inline elements leads to different ascender
     and descender heights; as we want to retain baseline alignment,
     remove leading to avoid altering the final height of lines
     note: this fails if these blocks take an entire line,
     a different solution would be great */
  line-height: 0;
}
:is(h1, h2, h3, h4, h5, h6) :is(tt, code) {
  font-size: 84%;
}
pre {
  border: 1px solid var(--line-color);
  font-size: 13.5px;
  line-height: 16px;
  letter-spacing: -0.2px;
  margin: 5px;
  padding: 5px;
}
img {
  max-width: 100%;
}
figure {
  margin: 0.5em 0;
  padding: 0;
}
figure blockquote {
  margin: 0.8em 0.4em 0.4em;
}
figcaption, caption {
  font-style: italic;
  margin: 0.5em 1.5em;
  text-align: left;
  caption-side: bottom;
}
@media screen {
  /* Auto-collapse boilerplate. */
  :is(#status-of-memo, #copyright) p {
    margin: -2px 0;
    max-height: 0;
    transition: max-height 2s ease, margin 0.5s ease 0.5s;
    overflow: hidden;
  }
  :is(#status-of-memo, #copyright):hover p,
  :is(#status-of-memo, #copyright) h2:target ~ p {
    margin: 0.5em 0;
    max-height: 500px;
    overflow: auto;
  }
  pre, svg {
    display: inline-block;
    /* In the horizontal direction, sometimes people make over-sized figures.
       Scrollbars for those is therefore necessary: auto adds them as necessary..
       In the vertical direction, the line-height can combine with the font
       asender/descender height to produce scrollbars: hidden avoids that. */
    overflow: auto hidden;
  }
  pre {
    max-width: 100%;
    width: calc(100% - 22px - 1em);
  }
  svg {
    max-width: calc(100% - 22px - 1em);
  }
  figure pre {
    display: block;
    width: calc(100% - 25px);
  }
  :is(pre, svg) + .pilcrow {
    display: inline-block;
    vertical-align: text-bottom;
    padding-bottom: 8px;
  }
}

/* aside, blockquote */
aside, blockquote {
  margin-left: 0;
  padding: 0 2em;
  font-style: italic;
}
blockquote {
  margin: 1em 0;
}
cite {
  display: block;
  text-align: right;
  font-style: italic;
}

/* tables */
table {
  width: auto;
  max-width: 100%;
  margin: 0 0 1em;
  border-collapse: collapse;
}
table.right {
  margin-left: auto;
}
table.center {
  margin-left: auto;
  margin-right: auto;
}
table.left {
  margin-right: auto;
}
table .text-left {
  text-align: left;
}
table .text-center {
  text-align: center;
}
table .text-right {
  text-align: right;
}

thead, tbody {
  border: 1px solid var(--line-color);
}
th, td {
  text-align: left;
  vertical-align: top;
  padding: 5px 10px;
}
th {
  background-color: var(--line-color);
}
:is(tr:nth-child(2n), thead+tbody > tr:nth-child(2n+1)) > td {
  background-color: var(--background-color);
}
:is(tr:nth-child(2n+1), thead+tbody > tr:nth-child(2n)) > td {
  background-color: var(--highlight-color);
}
table caption {
  margin: 0;
  padding: 3px 0 3px 1em;
}
table p {
  margin: 0;
}

/* pilcrow */
a.pilcrow {
  margin-left: 3px;
  opacity: 0.2;
  user-select: none;
  &[href] {
    color: var(--pilcrow-weak);
    &:hover { text-decoration: none; }
  }
}
@media not print {
  :hover > a.pilcrow {
    opacity: 1;
  }
  a.pilcrow[href]:hover {
    color: var(--pilcrow-strong);
    background-color: transparent;
  }
}
@media print {
  a.pilcrow {
    display: none;
  }
}

/* misc */
hr {
  border: 0;
  border-top: 1px solid var(--line-color);
}
.bcp14 {
  font-variant: small-caps;
  font-weight: 600;
  font-size: var(--small-font-size);
}
.role {
  font-variant: all-small-caps;
}
sub, sup {
  line-height: 1;
  font-size: 80%;
}

/* info block */
#identifiers {
  margin: 0;
  font-size: var(--small-font-size);
  line-height: 18px;
  --identifier-width: 15ch;
  & dt {
    width: var(--identifier-width);
    min-width: var(--identifier-width);
    clear: left;
    float: left;
    text-align: right;
    margin-right: 1ch;
  }
  & dd {
    margin: 0;
    margin-left: calc(1em + var(--identifier-width)) !important;
    min-width: 5em;
  }
  & .authors {
    & .author {
      display: inline-block;
      margin-right: 1.5em;
    }
    & .org {
      font-style: italic;
    }
  }
}

/* The prepared/rendered info at the very bottom of the page */
.docInfo {
  color: #999;
  font-size: 0.9em;
  font-style: italic;
  margin-top: 2em;
}
.docInfo .prepared {
  float: right;
}

/* table of contents */
#toc {
  padding: 0.75em 0 2em 0;
  margin-bottom: 1em;

  & nav {
    & ul {
      margin: 0 0.5em 0 0;
      padding: 0;
      list-style: none;
    }
    & li {
      line-height: 1.3em;
      margin: 2px 0;
      padding-left: 1.2em;
      text-indent: -1.2em;
    }
  }
  & a.xref {
    white-space: normal;
  }
}

.references {
  & > dt {
    text-align: right;
    font-weight: bold;
    min-width: 10ch;
    margin-right: 1.5ch;
    &:target::before {
      content: "⇒";
      margin: 0 10px 0 -25px;
    }
  }
  & > dd {
    margin-left: 12ch !important;
    overflow: visible;
    & .refInstance {
      margin-bottom: 0.8em;
    }
    & .ascii {
      margin-bottom: 0.25em;
    }
  }
}

#rfc\.index\.index + ul {
  margin-left: 0;
}

/* authors */
address.vcard {
  font-style: normal;
  max-width: 20em;
  margin: 1em auto 1em 0;

  & .nameRole {
    font-weight: 700;
    margin-left: 0;
  }
  & .label {
    margin: 0.5em 0;
  }
  & .type {
    display: none;
  }
  & .alternative-contact {
    margin: 0.5em 0 0.25em 0;
  }
  & .non-ascii {
    margin: 0 0 0 2em;
  }
  & div.left {
    text-align: left;
  }
  & div.right {
    text-align: right;
  }
}

hr.addr {
  border-top: 1px dashed;
  margin: 0;
  color: #ddd;
  max-width: calc(100% - 16px);
}
@media (min-width: 500px) {
  #authors-addresses > section {
    column-count: 2;
    column-gap: 20px;
  }
  #authors-addresses > section > h2 {
    column-span: all;
  }
  /* hack for break-inside: avoid-column */
  #authors-addresses address {
    display: inline-block;
    break-inside: avoid-column;
  }
}

/* Comments */
.rfcEditorRemove p:first-of-type {
  font-style: italic;
}
.cref {
  background-color: rgba(249, 232, 105, 0.3);
  padding: 2px 4px;
}
.crefSource {
  font-style: italic;
}

@media screen {
  #toc nav {
    font-family: var(--font-title);
    font-weight: 360;
    & > ul { margin-bottom: 2em; }
    & ul {
      margin: 0 0 0 4px;
      & :is(p, li) {
        margin: 2px 0;
      }
    }
  }
  #toc a.toplink {
    float: right;
  }
}
@media not screen {
  #toc a.toplink {
    display: none;
  }
}


/* TOC layout for smaller screens */
@media screen and (max-width: 929px) {
  #toc {
    position: fixed;
    z-index: 2;
    top: 0;
    right: 0;
    padding: 1px 0 0 0;
    margin: 0;
    border-bottom: 1px solid #ccc;
    opacity: 0.6;
  }
  #toc h2 {
    margin: 0;
    padding: 2px 0 2px 6px;
    padding-right: 1em;
    font-size: 18px;
    line-height: 24px;
    min-width: 190px;
    text-align: right;
    background-color: #444;
    color: white;
    cursor: pointer;
    &::before { /* css hamburger */
      float: right;
      position: relative;
      width: 1em;
      height: 1px;
      left: -164px;
      margin: 8px 0 0 0;
      background: white none repeat scroll 0 0;
      box-shadow: 0 4px 0 0 white, 0 8px 0 0 white;
      content: "";
    }
  }
  #toc nav {
    display: none;
    background-color: var(--background-color);
    padding: 0.5em 1em 1em;
    overflow: auto;
    overscroll-behavior: contain;
    height: calc(100vh - 48px);
    border-left: 1px solid #ddd;
  }
  #toc.active {
    opacity: 1;
    & nav { display: block; }
  }
  /* Make the collapsed ToC header render white on gray also when it's a link */
  #toc h2 a,
  #toc h2 a:is(:link, :focus, :hover),
  #toc a.toplink,
  #toc a.toplink:hover {
    color: white;
    background-color: #444;
    text-decoration: none;
  }
  #toc a.toplink {
    margin: 2px 0.5em 0;
  }
}

/* TOC layout for wide screens */
@media screen and (min-width: 930px) {
  body {
    padding-right: 360px;
    padding-right: calc(min(180px + 20%, 500px));
  }
  #toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 480px);
    width: 312px;
    margin: 0;
    padding: 0;
    z-index: 1;
  }
  #toc h2 {
    margin: 0;
    padding: 0.25em 1em 1em 0;
  }
  #toc nav {
    display: block;
    height: calc(90vh - 84px);
    bottom: 0;
    padding: 0.5em 0 2em;
    overflow: auto;
    overscroll-behavior: contain;
    scrollbar-width: thin;
  }
  img { /* future proofing */
    max-width: 100%;
    height: auto;
  }
  #toc a.toplink {
    margin: 8px 0.5em 0;
  }
}

/* pagination */
@media print {
  body {
    width: 100%;
  }
  p {
    orphans: 3;
    widows: 3;
  }
  #n-copyright-notice {
    border-bottom: none;
  }
  #toc, #n-introduction {
    page-break-before: always;
  }
  #toc {
    border-top: none;
    padding-top: 0;
  }
  figure, pre, .vcard {
    page-break-inside: avoid;
  }
  h1, h2, h3, h4, h5, h6 {
    page-break-after: avoid;
  }
  :is(h2, h3, h4, h5, h6)+*, dd {
    page-break-before: avoid;
  }
  pre {
    white-space: pre-wrap;
    word-wrap: break-word;
    font-size: 10pt;
  }
  table {
    border: 1px solid #ddd;
  }
  td {
    border-top: 1px solid #ddd;
  }
}

@page :first {
  padding-top: 0;
  @top-left {
    content: normal;
    border: none;
  }
  @top-center {
    content: normal;
    border: none;
  }
  @top-right {
    content: normal;
    border: none;
  }
}

@page {
  size: A4;
  margin-bottom: 45mm;
  padding-top: 20px;
}

/* Dark mode. */
@media (prefers-color-scheme: dark) {
:root {
  --background-color: #121212;
  --text-color: #f0f0f0;
  --title-color: #fff;
  --link-color: #4da4f0;
  --highlight-color: #282828;
  --line-color: #444;
  --pilcrow-weak: #444;
  --pilcrow-strong: #666;
  scrollbar-color: #777 #333;
}
}

/* SVG Trick: a prefix match works because only black and white are allowed */
svg :is([stroke="black"], [stroke^="#000"]) {
  stroke: var(--text-color);
}
svg :is([stroke="white"], [stroke^="#fff"]) {
  stroke: var(--background-color);
}
svg :is([fill="black"], [fill^="#000"], :not([fill])) {
  fill: var(--text-color);
}
svg :is([fill="white"], [fill^="#fff"]) {
  fill: var(--background-color);
}
</style>

</head>
<body class="xml2rfc">
<table class="ears">
<thead><tr>
<td class="left">Internet-Draft</td>
<td class="center">SCReAMv2</td>
<td class="right">December 2024</td>
</tr></thead>
<tfoot><tr>
<td class="left">Johansson &amp; Westerlund</td>
<td class="center">Expires 13 June 2025</td>
<td class="right">[Page]</td>
</tr></tfoot>
</table>
<div id="external-metadata" class="document-information"></div>
<div id="internal-metadata" class="document-information">
<dl id="identifiers">
<dt class="label-workgroup">Workgroup:</dt>
<dd class="workgroup">CCWG</dd>
<dt class="label-internet-draft">Internet-Draft:</dt>
<dd class="internet-draft">draft-johansson-ccwg-rfc8298bis-screamv2-latest</dd>
<dt class="label-obsoletes">Obsoletes:</dt>
<dd class="obsoletes">
<a href="https://www.rfc-editor.org/rfc/rfc8298" class="eref">8298</a> (if approved)</dd>
<dt class="label-published">Published:</dt>
<dd class="published">
<time datetime="2024-12-10" class="published">10 December 2024</time>
    </dd>
<dt class="label-intended-status">Intended Status:</dt>
<dd class="intended-status">Experimental</dd>
<dt class="label-expires">Expires:</dt>
<dd class="expires"><time datetime="2025-06-13">13 June 2025</time></dd>
<dt class="label-authors">Authors:</dt>
<dd class="authors">
<div class="author">
      <div class="author-name">I. Johansson</div>
<div class="org">Ericsson</div>
</div>
<div class="author">
      <div class="author-name">M. Westerlund</div>
<div class="org">Ericsson</div>
</div>
</dd>
</dl>
</div>
<h1 id="title">Self-Clocked Rate Adaptation for Multimedia</h1>
<section id="section-abstract">
      <h2 id="abstract"><a href="#abstract" class="selfRef">Abstract</a></h2>
<p id="section-abstract-1">This memo describes Self-Clocked Rate Adaptation for Multimedia version 2
(SCReAMv2), an update to SCReAM congestion control for media streams such as RTP
<span>[<a href="#RFC3550" class="cite xref">RFC3550</a>]</span>. SCReAMv2 compromised several algorithm simplifications and adds
support for L4S. The algorithm supports handling of multiple media streams,
typical use cases are streaming for remote control, ARand 3D VR googles.
This specification obsoletes RFC 8298.<a href="#section-abstract-1" class="pilcrow">¶</a></p>
</section>
<section class="note rfcEditorRemove" id="section-note.1">
      <h2 id="name-about-this-document">
<a href="#name-about-this-document" class="section-name selfRef">About This Document</a>
      </h2>
<p id="section-note.1-1">This note is to be removed before publishing as an RFC.<a href="#section-note.1-1" class="pilcrow">¶</a></p>
<p id="section-note.1-2">
        Status information for this document may be found at <span><a href="https://datatracker.ietf.org/doc/draft-johansson-ccwg-rfc8298bis-screamv2/">https://datatracker.ietf.org/doc/draft-johansson-ccwg-rfc8298bis-screamv2/</a></span>.<a href="#section-note.1-2" class="pilcrow">¶</a></p>
<p id="section-note.1-3">
        Discussion of this document takes place on the
        Congestion Control Working Group (ccwg) Working Group mailing list (<span><a href="mailto:ccwg@ietf.org">mailto:ccwg@ietf.org</a></span>),
        which is archived at <span><a href="https://mailarchive.ietf.org/arch/browse/ccwg/">https://mailarchive.ietf.org/arch/browse/ccwg/</a></span>.
        Subscribe at <span><a href="https://www.ietf.org/mailman/listinfo/ccwg/">https://www.ietf.org/mailman/listinfo/ccwg/</a></span>.<a href="#section-note.1-3" class="pilcrow">¶</a></p>
<p id="section-note.1-4">Source for this draft and an issue tracker can be found at
        <span><a href="https://github.com/gloinul/draft-johansson-ccwg-scream-bis">https://github.com/gloinul/draft-johansson-ccwg-scream-bis</a></span>.<a href="#section-note.1-4" class="pilcrow">¶</a></p>
</section>
<div id="status-of-memo">
<section id="section-boilerplate.1">
        <h2 id="name-status-of-this-memo">
<a href="#name-status-of-this-memo" class="section-name selfRef">Status of This Memo</a>
        </h2>
<p id="section-boilerplate.1-1">
        This Internet-Draft is submitted in full conformance with the
        provisions of BCP 78 and BCP 79.<a href="#section-boilerplate.1-1" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-2">
        Internet-Drafts are working documents of the Internet Engineering Task
        Force (IETF). Note that other groups may also distribute working
        documents as Internet-Drafts. The list of current Internet-Drafts is
        at <span><a href="https://datatracker.ietf.org/drafts/current/">https://datatracker.ietf.org/drafts/current/</a></span>.<a href="#section-boilerplate.1-2" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-3">
        Internet-Drafts are draft documents valid for a maximum of six months
        and may be updated, replaced, or obsoleted by other documents at any
        time. It is inappropriate to use Internet-Drafts as reference
        material or to cite them other than as "work in progress."<a href="#section-boilerplate.1-3" class="pilcrow">¶</a></p>
<p id="section-boilerplate.1-4">
        This Internet-Draft will expire on 13 June 2025.<a href="#section-boilerplate.1-4" class="pilcrow">¶</a></p>
</section>
</div>
<div id="copyright">
<section id="section-boilerplate.2">
        <h2 id="name-copyright-notice">
<a href="#name-copyright-notice" class="section-name selfRef">Copyright Notice</a>
        </h2>
<p id="section-boilerplate.2-1">
            Copyright (c) 2024 IETF Trust and the persons identified as the
            document authors. All rights reserved.<a href="#section-boilerplate.2-1" class="pilcrow">¶</a></p>
<p id="section-boilerplate.2-2">
            This document is subject to BCP 78 and the IETF Trust's Legal
            Provisions Relating to IETF Documents
            (<span><a href="https://trustee.ietf.org/license-info">https://trustee.ietf.org/license-info</a></span>) in effect on the date of
            publication of this document. Please review these documents
            carefully, as they describe your rights and restrictions with
            respect to this document. Code Components extracted from this
            document must include Revised BSD License text as described in
            Section 4.e of the Trust Legal Provisions and are provided without
            warranty as described in the Revised BSD License.<a href="#section-boilerplate.2-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="toc">
<section id="section-toc.1">
        <a href="#" onclick="scroll(0,0)" class="toplink">▲</a><h2 id="name-table-of-contents">
<a href="#name-table-of-contents" class="section-name selfRef">Table of Contents</a>
        </h2>
<nav class="toc"><ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1">
            <p id="section-toc.1-1.1.1"><a href="#section-1" class="auto internal xref">1</a>.  <a href="#name-introduction" class="internal xref">Introduction</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1.2.1">
                <p id="section-toc.1-1.1.2.1.1" class="keepWithNext"><a href="#section-1.1" class="auto internal xref">1.1</a>.  <a href="#name-updates-compared-to-scream-" class="internal xref">Updates compared to SCReAM (version 1)</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1.2.2">
                <p id="section-toc.1-1.1.2.2.1" class="keepWithNext"><a href="#section-1.2" class="auto internal xref">1.2</a>.  <a href="#name-requirements-on-media-and-f" class="internal xref">Requirements on media and feedback protocol</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.1.2.3">
                <p id="section-toc.1-1.1.2.3.1" class="keepWithNext"><a href="#section-1.3" class="auto internal xref">1.3</a>.  <a href="#name-comparison-with-ledbat-and-" class="internal xref">Comparison with LEDBAT and TFWC in TCP</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.2">
            <p id="section-toc.1-1.2.1"><a href="#section-2" class="auto internal xref">2</a>.  <a href="#name-requirements-language" class="internal xref">Requirements Language</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3">
            <p id="section-toc.1-1.3.1"><a href="#section-3" class="auto internal xref">3</a>.  <a href="#name-overview-of-screamv2-algori" class="internal xref">Overview of SCReAMv2 Algorithm</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.1">
                <p id="section-toc.1-1.3.2.1.1"><a href="#section-3.1" class="auto internal xref">3.1</a>.  <a href="#name-network-congestion-control" class="internal xref">Network Congestion Control</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.2">
                <p id="section-toc.1-1.3.2.2.1"><a href="#section-3.2" class="auto internal xref">3.2</a>.  <a href="#name-sender-transmission-control" class="internal xref">Sender Transmission Control</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.3.2.3">
                <p id="section-toc.1-1.3.2.3.1"><a href="#section-3.3" class="auto internal xref">3.3</a>.  <a href="#name-media-rate-control" class="internal xref">Media Rate Control</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4">
            <p id="section-toc.1-1.4.1"><a href="#section-4" class="auto internal xref">4</a>.  <a href="#name-detailed-description-of-scr" class="internal xref">Detailed Description of SCReAMv2 sender algorithm</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.1">
                <p id="section-toc.1-1.4.2.1.1"><a href="#section-4.1" class="auto internal xref">4.1</a>.  <a href="#name-sender-side-state" class="internal xref">Sender side state</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.2">
                <p id="section-toc.1-1.4.2.2.1"><a href="#section-4.2" class="auto internal xref">4.2</a>.  <a href="#name-network-congestion-control-2" class="internal xref">Network Congestion Control</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.2.2.1">
                    <p id="section-toc.1-1.4.2.2.2.1.1"><a href="#section-4.2.1" class="auto internal xref">4.2.1</a>.  <a href="#name-congestion-detection-delay-" class="internal xref">Congestion Detection: Delay, Data unit Loss and ECN-CE</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.2.2.2">
                    <p id="section-toc.1-1.4.2.2.2.2.1"><a href="#section-4.2.2" class="auto internal xref">4.2.2</a>.  <a href="#name-reference-window-update" class="internal xref">Reference Window Update</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.3">
                <p id="section-toc.1-1.4.2.3.1"><a href="#section-4.3" class="auto internal xref">4.3</a>.  <a href="#name-sender-transmission-control-2" class="internal xref">Sender Transmission Control</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.3.2.1">
                    <p id="section-toc.1-1.4.2.3.2.1.1"><a href="#section-4.3.1" class="auto internal xref">4.3.1</a>.  <a href="#name-send-window-calculation" class="internal xref">Send Window Calculation</a></p>
</li>
                  <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.3.2.2">
                    <p id="section-toc.1-1.4.2.3.2.2.1"><a href="#section-4.3.2" class="auto internal xref">4.3.2</a>.  <a href="#name-packet-pacing" class="internal xref">Packet Pacing</a></p>
</li>
                </ul>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.4">
                <p id="section-toc.1-1.4.2.4.1"><a href="#section-4.4" class="auto internal xref">4.4</a>.  <a href="#name-media-rate-control-2" class="internal xref">Media Rate Control</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.4.2.4.2.1">
                    <p id="section-toc.1-1.4.2.4.2.1.1"><a href="#section-4.4.1" class="auto internal xref">4.4.1</a>.  <a href="#name-handling-of-systematic-erro" class="internal xref">Handling of systematic errors in video coders</a></p>
</li>
                </ul>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.5">
            <p id="section-toc.1-1.5.1"><a href="#section-5" class="auto internal xref">5</a>.  <a href="#name-receiver-requirements-on-fe" class="internal xref">Receiver Requirements on Feedback Intensity</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.6">
            <p id="section-toc.1-1.6.1"><a href="#section-6" class="auto internal xref">6</a>.  <a href="#name-discussion" class="internal xref">Discussion</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.7">
            <p id="section-toc.1-1.7.1"><a href="#section-7" class="auto internal xref">7</a>.  <a href="#name-algorithm-changes" class="internal xref">Algorithm changes</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.8">
            <p id="section-toc.1-1.8.1"><a href="#section-8" class="auto internal xref">8</a>.  <a href="#name-iana-considerations" class="internal xref">IANA Considerations</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.9">
            <p id="section-toc.1-1.9.1"><a href="#section-9" class="auto internal xref">9</a>.  <a href="#name-security-considerations" class="internal xref">Security Considerations</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.10">
            <p id="section-toc.1-1.10.1"><a href="#section-10" class="auto internal xref">10</a>. <a href="#name-references" class="internal xref">References</a></p>
<ul class="compact toc ulBare ulEmpty">
<li class="compact toc ulBare ulEmpty" id="section-toc.1-1.10.2.1">
                <p id="section-toc.1-1.10.2.1.1"><a href="#section-10.1" class="auto internal xref">10.1</a>.  <a href="#name-normative-references" class="internal xref">Normative References</a></p>
</li>
              <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.10.2.2">
                <p id="section-toc.1-1.10.2.2.1"><a href="#section-10.2" class="auto internal xref">10.2</a>.  <a href="#name-informative-references" class="internal xref">Informative References</a></p>
</li>
            </ul>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.11">
            <p id="section-toc.1-1.11.1"><a href="#appendix-A" class="auto internal xref">Appendix A</a>.  <a href="#name-acknowledgments" class="internal xref">Acknowledgments</a></p>
</li>
          <li class="compact toc ulBare ulEmpty" id="section-toc.1-1.12">
            <p id="section-toc.1-1.12.1"><a href="#appendix-B" class="auto internal xref"></a><a href="#name-authors-addresses" class="internal xref">Authors' Addresses</a></p>
</li>
        </ul>
</nav>
</section>
</div>
<div id="introduction">
<section id="section-1">
      <h2 id="name-introduction">
<a href="#section-1" class="section-number selfRef">1. </a><a href="#name-introduction" class="section-name selfRef">Introduction</a>
      </h2>
<p id="section-1-1">This memo describes Self-Clocked Rate Adaptation for Multimedia version 2
(SCReAMv2). This specification replaces the previous experimental version <span>[<a href="#RFC8298" class="cite xref">RFC8298</a>]</span> of
SCReAM with SCReAMv2. There are many and fairly significant changes to the
original SCReAM algorithm as desribed in section <a href="#sec_changes" class="auto internal xref">Section 1.1</a>.<a href="#section-1-1" class="pilcrow">¶</a></p>
<p id="section-1-2">Both SCReAM and SCReAMv2 estimates the forward queue delay in the same way as Low
Extra Delay Background Transport (LEDBAT) <span>[<a href="#RFC6817" class="cite xref">RFC6817</a>]</span>.
However, while SCReAM is based on the self-clocking principle of TCP,
SCReAMv2 is not entirely self-clocked as it augments self-clocking with pacing
and a minimum send rate.<a href="#section-1-2" class="pilcrow">¶</a></p>
<p id="section-1-3">Further, SCReAMv2 can take advantage of Explicit
Congestion Notification (ECN) <span>[<a href="#RFC3168" class="cite xref">RFC3168</a>]</span> and Low Latency Low Loss and Scalable
throughput (L4S) <span>[<a href="#RFC9330" class="cite xref">RFC9330</a>]</span> in cases where ECN or L4S is supported by the
network and the hosts. However, ECN or L4S is not required for the basic
congestion control functionality in SCReAMv2.<a href="#section-1-3" class="pilcrow">¶</a></p>
<div id="sec_changes">
<section id="section-1.1">
        <h3 id="name-updates-compared-to-scream-">
<a href="#section-1.1" class="section-number selfRef">1.1. </a><a href="#name-updates-compared-to-scream-" class="section-name selfRef">Updates compared to SCReAM (version 1)</a>
        </h3>
<p id="section-1.1-1">The algorithm in this memo differs greatly against the previous version of
SCReAM. The main differences are:<a href="#section-1.1-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-1.1-2.1">
            <p id="section-1.1-2.1.1">L4S support added. The L4S algoritm has many similarities with the DCTCP and
Prague congestion control but has a few extra modifications to make it work
well with peridic sources such as video.<a href="#section-1.1-2.1.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-2.2">
            <p id="section-1.1-2.2.1">The delay based congestion control is changed to implement a pseudo-L4S
approach, this simplifies the delay based congestion control.<a href="#section-1.1-2.2.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-2.3">
            <p id="section-1.1-2.3.1">The fast increase mode is removed. The reference window additive increase is
replaced with an adaptive multiplicative increase to enhance convergence
speed.<a href="#section-1.1-2.3.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-2.4">
            <p id="section-1.1-2.4.1">The algorithm is more rate based than self-clocked:<a href="#section-1.1-2.4.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-1.1-2.4.2.1">
                <p id="section-1.1-2.4.2.1.1">The calculated congestion window is mainly used to calculate proper media bitrates. Bytes in flight is
however allowed to exceeed the reference window. Therefore, The term
reference window is used instead of congestion window, as the reference
window does not set an absolute limit on the bytes in flight.<a href="#section-1.1-2.4.2.1.1" class="pilcrow">¶</a></p>
</li>
              <li class="normal" id="section-1.1-2.4.2.2">
                <p id="section-1.1-2.4.2.2.1">The self-clocking now acts more like an emergency break
as bytes in flight can exceed the reference window only to a certain
degree. The rationale is to be able to transmit large video frames and avoid
that they are unnecessarily queued up on the sender side, but still prevent a
large network queue.<a href="#section-1.1-2.4.2.2.1" class="pilcrow">¶</a></p>
</li>
            </ul>
</li>
          <li class="normal" id="section-1.1-2.5">
            <p id="section-1.1-2.5.1">The media bitrate calculation is dramatically changed and simplified.<a href="#section-1.1-2.5.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.1-2.6">
            <p id="section-1.1-2.6.1">Additional compensation is added to make SCReAMv2 handle cases such as large
changing frame sizes.<a href="#section-1.1-2.6.1" class="pilcrow">¶</a></p>
</li>
        </ul>
</section>
</div>
<div id="requirements-media">
<section id="section-1.2">
        <h3 id="name-requirements-on-media-and-f">
<a href="#section-1.2" class="section-number selfRef">1.2. </a><a href="#name-requirements-on-media-and-f" class="section-name selfRef">Requirements on media and feedback protocol</a>
        </h3>
<p id="section-1.2-1">SCReAM was originally designed to with with RTP + RTCP where <span>[<a href="#RFC8888" class="cite xref">RFC8888</a>]</span> was
used as recommended feedback. RTP offers unique packet indication with the
sequence number and <span>[<a href="#RFC8888" class="cite xref">RFC8888</a>]</span> offers timestamps of received packets and the
status of the ECN bits.<a href="#section-1.2-1" class="pilcrow">¶</a></p>
<p id="section-1.2-2">SCReAM is however not limited to RTP as long as some requirements are fulfilled :<a href="#section-1.2-2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-1.2-3.1">
            <p id="section-1.2-3.1.1">Media data is split in data units that when encapsulated in IP packets fit in
the network MTU.<a href="#section-1.2-3.1.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.2-3.2">
            <p id="section-1.2-3.2.1">Each data unit can be uniquely identified.<a href="#section-1.2-3.2.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.2-3.3">
            <p id="section-1.2-3.3.1">Data units can be queued up in a packet queue before transmission.<a href="#section-1.2-3.3.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.2-3.4">
            <p id="section-1.2-3.4.1">Feedback can indicate reception time for each data units, or a group of data
units.<a href="#section-1.2-3.4.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-1.2-3.5">
            <p id="section-1.2-3.5.1">Feedback can indicate packets that are ECN-CE marked. Unique ECN bits
indication for each packet is not necessary. An ECN-CE counter similar to
what is defined in <span>[<a href="#RFC9000" class="cite xref">RFC9000</a>]</span> is sufficient.<a href="#section-1.2-3.5.1" class="pilcrow">¶</a></p>
</li>
        </ul>
</section>
</div>
<div id="ledbat-tfwc">
<section id="section-1.3">
        <h3 id="name-comparison-with-ledbat-and-">
<a href="#section-1.3" class="section-number selfRef">1.3. </a><a href="#name-comparison-with-ledbat-and-" class="section-name selfRef">Comparison with LEDBAT and TFWC in TCP</a>
        </h3>
<p id="section-1.3-1">The core SCReAM algorithm, which is still similar in SCReAMv2, has similarities
to the concepts of self-clocking used in TCP-friendly window-based congestion
control <span>[<a href="#TFWC" class="cite xref">TFWC</a>]</span> and follows the packet conservation principle. The packet
conservation principle is described as a key factor behind the protection of
networks from congestion <span>[<a href="#Packet-conservation" class="cite xref">Packet-conservation</a>]</span>.<a href="#section-1.3-1" class="pilcrow">¶</a></p>
<p id="section-1.3-2">The reference window decrase is determined in a way similar as in
LEDBAT <span>[<a href="#RFC6817" class="cite xref">RFC6817</a>]</span>. However, the window increase is not based on the
delay but uses both a linear increase and multiplicate increase function depending
on the time since the last congestion event and introduces use of inflection points in the
reference window increase calculation to achieve reduced delay jitter.
Further, other than LEDABT which is a scavenger congestion control mostly designed
for low priority background traffic, SCReAM adjusts the qdelay target to
compete with other loss-based congestion-controlled flows.<a href="#section-1.3-2" class="pilcrow">¶</a></p>
<p id="section-1.3-3">SCReAMv2 adds a new reference window validation technique, as the reference window is used as a basis for the
target bitrate calculation. For that reason, various actions are taken to avoid
that the reference window grows too much beyond the bytes in flight. Additional
contraints are applied when in congested state and when the maximum target bitrate is reached.<a href="#section-1.3-3" class="pilcrow">¶</a></p>
<p id="section-1.3-4">The SCReAM/SCReAMv2 congestion control method uses techniques similar to LEDBAT
<span>[<a href="#RFC6817" class="cite xref">RFC6817</a>]</span> to measure the qdelay. As is the case with LEDBAT, it is not
necessary to use synchronized clocks in the sender and receiver in order to
compute the qdelay. However, it is necessary that they use the same clock
frequency, or that the clock frequency at the receiver can be inferred reliably
by the sender. Failure to meet this requirement leads to malfunction in the
SCReAM/SCReAMv2 congestion control algorithm due to incorrect estimation of the
network queue delay. Use of <span>[<a href="#RFC8888" class="cite xref">RFC8888</a>]</span> as feedback ensures that the same time
base is used in sender and receiver.<a href="#section-1.3-4" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="requirements">
<section id="section-2">
      <h2 id="name-requirements-language">
<a href="#section-2" class="section-number selfRef">2. </a><a href="#name-requirements-language" class="section-name selfRef">Requirements Language</a>
      </h2>
<p id="section-2-1">The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
"SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this
document are to be interpreted as described in BCP 14 <span>[<a href="#RFC2119" class="cite xref">RFC2119</a>]</span> <span>[<a href="#RFC8174" class="cite xref">RFC8174</a>]</span>
when, and only when, they appear in all capitals, as shown here.<a href="#section-2-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="scream-overview">
<section id="section-3">
      <h2 id="name-overview-of-screamv2-algori">
<a href="#section-3" class="section-number selfRef">3. </a><a href="#name-overview-of-screamv2-algori" class="section-name selfRef">Overview of SCReAMv2 Algorithm</a>
      </h2>
<p id="section-3-1">SCReAMv2 still consists of three main parts: network congestion control, sender
transmission control, and media rate control. All of these parts reside at the
sender side while the receiver is assumpted to provide acknowledgements of received
data units and indication of ECN-CE marking, either as an accumulated bytes counter,
or per individual data unit.<a href="#section-3-1" class="pilcrow">¶</a></p>
<p id="section-3-2">The sender implements media rate control and an data unit queue for each media
type or source, where data units containing encoded media frames are temporarily
stored for transmission. Figure 1 shows the details when a single media source
(or stream) is used. Scheduling and priotization of mulitiple streams is not
covered in this document. However, if multiple flows are sent, each data unit queue can be
served based on some defined priority or simply in a round-robin fashion. Alternatively,
a similar approach as coupled congestion control {RFC6365} can be applied.<a href="#section-3-2" class="pilcrow">¶</a></p>
<span id="name-sender-functional-view"></span><div id="fig-sender-view">
<figure id="figure-1">
        <div id="section-3-3.1">
          <div class="alignLeft art-svg artwork" id="section-3-3.1.1">
<svg xmlns="http://www.w3.org/2000/svg" version="1.1" height="528" width="472" viewBox="0 0 472 528" class="diagram" text-anchor="middle" font-family="monospace" font-size="13px" stroke-linecap="round">
              <path d="M 8,32 L 8,64" fill="none" stroke="black"></path>
              <path d="M 8,160 L 8,224" fill="none" stroke="black"></path>
              <path d="M 8,320 L 8,384" fill="none" stroke="black"></path>
              <path d="M 8,480 L 8,512" fill="none" stroke="black"></path>
              <path d="M 64,72 L 64,96" fill="none" stroke="black"></path>
              <path d="M 64,120 L 64,152" fill="none" stroke="black"></path>
              <path d="M 64,232 L 64,256" fill="none" stroke="black"></path>
              <path d="M 64,392 L 64,416" fill="none" stroke="black"></path>
              <path d="M 112,160 L 112,224" fill="none" stroke="black"></path>
              <path d="M 112,320 L 112,384" fill="none" stroke="black"></path>
              <path d="M 240,192 L 240,224" fill="none" stroke="black"></path>
              <path d="M 240,248 L 240,336" fill="none" stroke="black"></path>
              <path d="M 336,320 L 336,384" fill="none" stroke="black"></path>
              <path d="M 344,144 L 344,240" fill="none" stroke="black"></path>
              <path d="M 384,128 L 384,136" fill="none" stroke="black"></path>
              <path d="M 392,288 L 392,312" fill="none" stroke="black"></path>
              <path d="M 392,392 L 392,416" fill="none" stroke="black"></path>
              <path d="M 392,448 L 392,472" fill="none" stroke="black"></path>
              <path d="M 440,144 L 440,240" fill="none" stroke="black"></path>
              <path d="M 456,320 L 456,384" fill="none" stroke="black"></path>
              <path d="M 464,32 L 464,64" fill="none" stroke="black"></path>
              <path d="M 464,480 L 464,512" fill="none" stroke="black"></path>
              <path d="M 8,32 L 464,32" fill="none" stroke="black"></path>
              <path d="M 8,64 L 464,64" fill="none" stroke="black"></path>
              <path d="M 344,144 L 440,144" fill="none" stroke="black"></path>
              <path d="M 8,160 L 112,160" fill="none" stroke="black"></path>
              <path d="M 120,192 L 240,192" fill="none" stroke="black"></path>
              <path d="M 8,224 L 112,224" fill="none" stroke="black"></path>
              <path d="M 344,240 L 440,240" fill="none" stroke="black"></path>
              <path d="M 8,320 L 112,320" fill="none" stroke="black"></path>
              <path d="M 336,320 L 456,320" fill="none" stroke="black"></path>
              <path d="M 240,336 L 328,336" fill="none" stroke="black"></path>
              <path d="M 120,368 L 328,368" fill="none" stroke="black"></path>
              <path d="M 8,384 L 112,384" fill="none" stroke="black"></path>
              <path d="M 336,384 L 456,384" fill="none" stroke="black"></path>
              <path d="M 8,480 L 464,480" fill="none" stroke="black"></path>
              <path d="M 8,512 L 464,512" fill="none" stroke="black"></path>
              <polygon class="arrowhead" points="400,472 388,466.4 388,477.6" fill="black" transform="rotate(90,392,472)"></polygon>
              <polygon class="arrowhead" points="400,312 388,306.4 388,317.6" fill="black" transform="rotate(90,392,312)"></polygon>
              <polygon class="arrowhead" points="392,136 380,130.4 380,141.6" fill="black" transform="rotate(90,384,136)"></polygon>
              <polygon class="arrowhead" points="336,368 324,362.4 324,373.6" fill="black" transform="rotate(0,328,368)"></polygon>
              <polygon class="arrowhead" points="336,336 324,330.4 324,341.6" fill="black" transform="rotate(0,328,336)"></polygon>
              <polygon class="arrowhead" points="72,392 60,386.4 60,397.6" fill="black" transform="rotate(270,64,392)"></polygon>
              <polygon class="arrowhead" points="72,232 60,226.4 60,237.6" fill="black" transform="rotate(270,64,232)"></polygon>
              <polygon class="arrowhead" points="72,72 60,66.4 60,77.6" fill="black" transform="rotate(270,64,72)"></polygon>
              <g class="text">
                <text x="216" y="52">Media</text>
                <text x="272" y="52">encoder</text>
                <text x="384" y="84">|</text>
                <text x="372" y="100">Data</text>
                <text x="412" y="100">unit</text>
                <text x="68" y="116">target_bitrate</text>
                <text x="384" y="116">|</text>
                <text x="64" y="180">Media</text>
                <text x="392" y="180">Queue</text>
                <text x="60" y="196">Rate</text>
                <text x="388" y="196">Data</text>
                <text x="64" y="212">Control</text>
                <text x="392" y="212">Units</text>
                <text x="244" y="244">target_bitrate</text>
                <text x="392" y="260">|</text>
                <text x="64" y="276">ref_wnd</text>
                <text x="380" y="276">Data</text>
                <text x="420" y="276">unit</text>
                <text x="64" y="292">RTT</text>
                <text x="64" y="308">|</text>
                <text x="56" y="340">Network</text>
                <text x="396" y="340">Sender</text>
                <text x="60" y="356">Congestion</text>
                <text x="184" y="356">ref_wnd</text>
                <text x="396" y="356">Transmission</text>
                <text x="56" y="372">Control</text>
                <text x="392" y="372">Control</text>
                <text x="176" y="388">Bytes</text>
                <text x="212" y="388">in</text>
                <text x="252" y="388">flight</text>
                <text x="44" y="436">Congestion</text>
                <text x="124" y="436">Feedback</text>
                <text x="380" y="436">Data</text>
                <text x="420" y="436">unit</text>
                <text x="40" y="452">Bytes</text>
                <text x="76" y="452">in</text>
                <text x="116" y="452">flight</text>
                <text x="64" y="468">|</text>
                <text x="216" y="500">UDP</text>
                <text x="260" y="500">socket</text>
              </g>
            </svg><a href="#section-3-3.1.1" class="pilcrow">¶</a>
</div>
</div>
<figcaption><a href="#figure-1" class="selfRef">Figure 1</a>:
<a href="#name-sender-functional-view" class="selfRef">Sender Functional View</a>
        </figcaption></figure>
</div>
<p id="section-3-4">Media frames are encoded and forwarded to the data unit queue in
<a href="#fig-sender-view" class="auto internal xref">Figure 1</a>. The data units are sent by the sender transmission controller
from the data unit queue.<a href="#section-3-4" class="pilcrow">¶</a></p>
<p id="section-3-5">The sender transmission controller (in case of multiple flows a transmission
scheduler) sends the data units to the UDP socket. The sender transmission
controller limits the sending rate so
that the number of bytes in flight is less than the reference window albeit with
a slack to avoid that packets are unnecessarily delayed in the data unit queue.
A apcing rate is calculated based on the target bitrate provided by the
media rate controller.<a href="#section-3-5" class="pilcrow">¶</a></p>
<p id="section-3-6">Feedback about the received bytes as well as metadata to estimatethe congestion
level or queuing delay are provided to the network congestion controller.
The network congestion controller calculated reference window and provides it
togteher with the bytes in flight to the sender transmission control (7).<a href="#section-3-6" class="pilcrow">¶</a></p>
<p id="section-3-7">The reference window and the estimated RTT is further provided to the media rate
control to compute the appropriate target bitrate. The target bitrate is
updated whenever the reference window is updated. Additional parameters are also
communicated to make the rate control more stable when the congestion window is
very small or when L4S is not active. This is described more in detail below.<a href="#section-3-7" class="pilcrow">¶</a></p>
<div id="network-cc">
<section id="section-3.1">
        <h3 id="name-network-congestion-control">
<a href="#section-3.1" class="section-number selfRef">3.1. </a><a href="#name-network-congestion-control" class="section-name selfRef">Network Congestion Control</a>
        </h3>
<p id="section-3.1-1">The network congestion control sets reference window (ref_wnd)
which puts an upper limit on how many bytes can be in
flight, i.e., transmitted but not yet acknowledged. The reference window is
however not an absolute limit as slack is given to efficiently transmit
temporary larger media objects, such as video frames. This means that the
algoritm prefers to build up a queue in the network rather than on the sender
side. Additional congestion that this causes will reflect back and cause a
reduction of the reference window.<a href="#section-3.1-1" class="pilcrow">¶</a></p>
<p id="section-3.1-2">After a congestion event the reference window seeks to increase by one segment per RTT
until a certain number of RTT elapses. After this initial phase the refrence window
increases multiplicativly where the increase factor is adjusted relative to a
previous max value and the time elapsed since last congestion event.
This enables a faster convergence to a higher link speed.<a href="#section-3.1-2" class="pilcrow">¶</a></p>
<p id="section-3.1-3">Reference window is reduced if congestion is detected. Similar as for LEDBAT
the reference window is reduced either by a fixed fraction in case of packet loss or Classic ECN marking,
or if the estimated queue delay exceeds a given threshold depending on how much the delay exceeds the threshold.
SCReAMv2 reduces the reference window in proportion to the fraction of marked packets
if L4S is used (scalable congestion control).<a href="#section-3.1-3" class="pilcrow">¶</a></p>
</section>
</div>
<div id="sender-tc">
<section id="section-3.2">
        <h3 id="name-sender-transmission-control">
<a href="#section-3.2" class="section-number selfRef">3.2. </a><a href="#name-sender-transmission-control" class="section-name selfRef">Sender Transmission Control</a>
        </h3>
<p id="section-3.2-1">The sender transmission control limits sending rate based on the
relation of the estimated link throughput (bytes in flight) and the reference window.
This is achived by applying packet pacing: Even if the send window allows for the transmission
of a number of packets, these packets are not transmitted immediately; rather,
they are transmitted in intervals given by the packet size and the estimated
link throughput. Packets are generally paced at a higher rate than the target
bitrate, this makes it possible to transmit occasionally larger video frames in
a timely manner. Further, this mitigates issues with ACK compression that can cause
increased jitter and/or packet loss in the media traffic.<a href="#section-3.2-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="media-rate-control">
<section id="section-3.3">
        <h3 id="name-media-rate-control">
<a href="#section-3.3" class="section-number selfRef">3.3. </a><a href="#name-media-rate-control" class="section-name selfRef">Media Rate Control</a>
        </h3>
<p id="section-3.3-1">The media rate control calculates the media rate based on the reference window and RTT.
The media rate need to ramp up quickly enough to get a fair share of the system resources when link throughput
increases. Further, the reaction to reduced throughput must be prompt in order to avoid getting too
much data queued in the data unit queue(s) in the sender.<a href="#section-3.3-1" class="pilcrow">¶</a></p>
<p id="section-3.3-2">For the case that multiple
streams are enabled, the media rate among the streams is distrubuted according
to relative priorities.<a href="#section-3.3-2" class="pilcrow">¶</a></p>
<p id="section-3.3-3">In cases where the sender's frame queues increase rapidly, such as in the case
of a Radio Access Type (RAT) handover, the SCReAMv2 sender MAY implement
additional actions, such as discarding of encoded media frames or frame skipping
in order to ensure that the data unit queues are drained quickly. Frame skipping
results in the frame rate being temporarily reduced. Which method to use is a
design choice and is outside the scope of this algorithm description.<a href="#section-3.3-3" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="scream-detailed-description">
<section id="section-4">
      <h2 id="name-detailed-description-of-scr">
<a href="#section-4" class="section-number selfRef">4. </a><a href="#name-detailed-description-of-scr" class="section-name selfRef">Detailed Description of SCReAMv2 sender algorithm</a>
      </h2>
<p id="section-4-1">This section describes the sender-side algorithm in more detail. It is split
between the network congestion control, sender transmission control, and media
rate control.<a href="#section-4-1" class="pilcrow">¶</a></p>
<div id="sender-side-state">
<section id="section-4.1">
        <h3 id="name-sender-side-state">
<a href="#section-4.1" class="section-number selfRef">4.1. </a><a href="#name-sender-side-state" class="section-name selfRef">Sender side state</a>
        </h3>
<p id="section-4.1-1">The sender needs to maintain sending state as well as state about the received
feedback, covered by the following variables:<a href="#section-4.1-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.1-2.1">
            <p id="section-4.1-2.1.1">bytes_in_flight:<a href="#section-4.1-2.1.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-4.1-2.2">
            <p id="section-4.1-2.2.1">bytes_in_flight_ratio (0.0): Ratio between the bytes in flight and the
reference window.<a href="#section-4.1-2.2.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-4.1-2.3">
            <p id="section-4.1-2.3.1">ref_wnd_ratio (0.0): Ratio between MSS and ref_wnd.<a href="#section-4.1-2.3.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-4.1-2.4">
            <p id="section-4.1-2.4.1">s_rtt (0.0): Smoothed RTT [s], computed with a similar method to that
described in <span>[<a href="#RFC6298" class="cite xref">RFC6298</a>]</span>.<a href="#section-4.1-2.4.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-4.1-2.5">
            <p id="section-4.1-2.5.1">qdelay:<a href="#section-4.1-2.5.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-4.1-2.6">
            <p id="section-4.1-2.6.1">last_update_qdelay_avg_time (0): Last time qdelay_avg was updated [s].<a href="#section-4.1-2.6.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-4.1-2.7">
            <p id="section-4.1-2.7.1">loss_event_rate (0.0): The estimated fraction of RTTs with lost data units
detected.<a href="#section-4.1-2.7.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-4.1-2.8">
            <p id="section-4.1-2.8.1">bytes_newly_acked (0): Number of bytes newly ACKed, reset to 0 when congestion
window is updated [byte].<a href="#section-4.1-2.8.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-4.1-2.9">
            <p id="section-4.1-2.9.1">bytes_newly_acked_ce (0): Number of bytes newly ACKed and CE marked, reset to
0 when reference window is updated [byte].<a href="#section-4.1-2.9.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-4.1-2.10">
            <p id="section-4.1-2.10.1">data_unit_size (0): Size [byte] of the last transmitted data unit.<a href="#section-4.1-2.10.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-4.1-2.11">
            <p id="section-4.1-2.11.1">data_units_acked:<a href="#section-4.1-2.11.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-4.1-2.12">
            <p id="section-4.1-2.12.1">data_units_acked_ce:<a href="#section-4.1-2.12.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-4.1-2.13">
            <p id="section-4.1-2.13.1">l4s_active (false): Indicates that L4S is enabled and data units are indeed
marked.<a href="#section-4.1-2.13.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-4.1-3">SCReAMv2 is a window-based and byte-oriented congestion control
protocol, where the number of bytes transmitted is inferred from the
size of the transmitted data units. Thus, a list of transmitted data
units and their respective transmission times (wall-clock time) MUST
be kept for further calculation.<a href="#section-4.1-3" class="pilcrow">¶</a></p>
<p id="section-4.1-4">The number of bytes in flight (bytes_in_flight) is computed as the sum of the
sizes of the data units ranging from the data unit most recently transmitted,
down to but not including the acknowledged data unit with the highest sequence
number. This can be translated to the difference between the highest transmitted
byte sequence number and the highest acknowledged byte sequence number. As an
example: If a data unit with sequence number SN is transmitted and the last
acknowledgement indicates SN-5 as the highest received sequence number, then
bytes_in_flight is computed as the sum of the size of data units with sequence
number SN-4, SN-3, SN-2, SN-1, and SN. It does not matter if, for instance, the
data unit with sequence number SN-3 was lost -- the size of data unit with
sequence number SN-3 will still be considered in the computation of
bytes_in_flight.<a href="#section-4.1-4" class="pilcrow">¶</a></p>
<p id="section-4.1-5">bytes_in_flight_ratio is calculated as the ratio between bytes_flight and
ref_wnd. This value should be computed at the beginning of the ACK
processing. ref_wnd_ratio is computed as the relation between MSS and ref_wnd.<a href="#section-4.1-5" class="pilcrow">¶</a></p>
<p id="section-4.1-6">Furthermore, a variable bytes_newly_acked is incremented with a value
corresponding to how much the highest sequence number has increased
since the last feedback. As an example: If the previous
acknowledgement indicated the highest sequence number N and the new
acknowledgement indicated N+3, then bytes_newly_acked is incremented
by a value equal to the sum of the sizes of data units with sequence
number N+1, N+2, and N+3. Data units that are lost are also included,
which means that even though, e.g., data unit N+2 was lost, its size
is still included in the update of bytes_newly_acked. The
bytes_newly_acked_ce is, similar to bytes_newly_acked, a counter of
bytes newly acked with the extra condition that they are ECN-CE
marked. The bytes_newly_acked and bytes_newly_acked_ce are reset to
zero after a ref_wnd update.<a href="#section-4.1-6" class="pilcrow">¶</a></p>
<p id="section-4.1-7">When the sender receives RTCP feedback, the qdelay is calculated as outlined in
<span>[<a href="#RFC6817" class="cite xref">RFC6817</a>]</span>. A qdelay sample is obtained for each received acknowledgement.<a href="#section-4.1-7" class="pilcrow">¶</a></p>
<p id="section-4.1-8">The smoothed RTT (s_rtt) is computed in a way similar to <span>[<a href="#RFC6298" class="cite xref">RFC6298</a>]</span>.<a href="#section-4.1-8" class="pilcrow">¶</a></p>
<p id="section-4.1-9">The feedback from the receiver is assumed to consist of the following elements.<a href="#section-4.1-9" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.1-10.1">
            <p id="section-4.1-10.1.1">A list of received data units' sequence numbers. With an indication
if data units are ECN-CE marked, the ECN status can be either per
data unit or an accumulated count of ECN-CE marked data units.<a href="#section-4.1-10.1.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-4.1-10.2">
            <p id="section-4.1-10.2.1">The wall-clock timestamp corresponding to the received data unit with the
highest sequence number.<a href="#section-4.1-10.2.1" class="pilcrow">¶</a></p>
</li>
        </ul>
</section>
</div>
<div id="network-cc-2">
<section id="section-4.2">
        <h3 id="name-network-congestion-control-2">
<a href="#section-4.2" class="section-number selfRef">4.2. </a><a href="#name-network-congestion-control-2" class="section-name selfRef">Network Congestion Control</a>
        </h3>
<p id="section-4.2-1">This section explains the network congestion control, which calcultes the
reference window. The reference window gives an upper limit to the number of bytes in flight.<a href="#section-4.2-1" class="pilcrow">¶</a></p>
<div id="reaction-delay-loss-ce">
<section id="section-4.2.1">
          <h4 id="name-congestion-detection-delay-">
<a href="#section-4.2.1" class="section-number selfRef">4.2.1. </a><a href="#name-congestion-detection-delay-" class="section-name selfRef">Congestion Detection: Delay, Data unit Loss and ECN-CE</a>
          </h4>
<p id="section-4.2.1-1">Congestion is detected based on three different indicators:<a href="#section-4.2.1-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.2.1-2.1">
              <p id="section-4.2.1-2.1.1">Lost data units detected,<a href="#section-4.2.1-2.1.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-4.2.1-2.2">
              <p id="section-4.2.1-2.2.1">ECN-CE marked data units detected either for classic ECN or L4S,<a href="#section-4.2.1-2.2.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-4.2.1-2.3">
              <p id="section-4.2.1-2.3.1">Estimated queue delay exceeds a threshold.<a href="#section-4.2.1-2.3.1" class="pilcrow">¶</a></p>
</li>
          </ul>
<p id="section-4.2.1-3">A congestion event occurs if any of the above indicators are true AND it is at
least min(VIRTUAL_RTT,s_rtt) since the last congestion event. This ensures that
the reference window is reduced at most once per smoothed RTT.<a href="#section-4.2.1-3" class="pilcrow">¶</a></p>
<div id="reaction-loss">
<section id="section-4.2.1.1">
            <h5 id="name-lost-data-units">
<a href="#section-4.2.1.1" class="section-number selfRef">4.2.1.1. </a><a href="#name-lost-data-units" class="section-name selfRef">Lost data units</a>
            </h5>
<p id="section-4.2.1.1-1">The reference window back-off due to loss events is deliberately a bit less than
is the case with TCP Reno, for example. TCP is generally used to transmit whole
files; the file is then like a source with an infinite bitrate until the whole
file has been transmitted. SCReAMv2, on the other hand, has a source which rate
is limited to a value close to the available transmit rate and often below that
value; the effect is that SCReAMv2 has less opportunity to grab free capacity
than a TCP-based file transfer. To compensate for this, it is RECOMMENDED to let
SCReAMv2 reduce the reference window less than what is the case with TCP when
loss events occur.<a href="#section-4.2.1.1-1" class="pilcrow">¶</a></p>
<p id="section-4.2.1.1-2">Lost data unit detection is based on the received sequence number list. A
reordering window SHOULD be applied to prevent data unit reordering from triggering
loss events. The reordering window is specified as a time unit, similar to the
ideas behind Recent ACKnowledgement (RACK) <span>[<a href="#RFC8985" class="cite xref">RFC8985</a>]</span>. The computation of the
reordering window is made possible by means of a lost flag in the list of
transmitted data units. This flag is set if the received sequence number list
indicates that the given data unit is missing. If later feedback indicates that
a previously lost marked data unit was indeed received, then the reordering window
is updated to reflect the reordering delay. The reordering window is given by
the difference in time between the event that the data unit was marked as lost and
the event that it was indicated as successfully received. Loss is detected if a
given data unit is not acknowledged within a time window (indicated by the
reordering window) after an data unit with a higher sequence number was
acknowledged.<a href="#section-4.2.1.1-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="reaction-ecn-ce">
<section id="section-4.2.1.2">
            <h5 id="name-ecn-ce-and-classic-ecn">
<a href="#section-4.2.1.2" class="section-number selfRef">4.2.1.2. </a><a href="#name-ecn-ce-and-classic-ecn" class="section-name selfRef">ECN-CE and classic ECN</a>
            </h5>
<p id="section-4.2.1.2-1">In classic ECN mode the ref_wnd is scaled by a fixed value (BETA_ECN).<a href="#section-4.2.1.2-1" class="pilcrow">¶</a></p>
<p id="section-4.2.1.2-2">The reference window back-off due to an ECN event MAY be smaller than if a loss
event occurs. This is in line with the idea outlined in <span>[<a href="#RFC8511" class="cite xref">RFC8511</a>]</span> to enable
ECN marking thresholds lower than the corresponding data unit drop thresholds.<a href="#section-4.2.1.2-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="reaction-l4s-ce">
<section id="section-4.2.1.3">
            <h5 id="name-ecn-ce-and-l4s">
<a href="#section-4.2.1.3" class="section-number selfRef">4.2.1.3. </a><a href="#name-ecn-ce-and-l4s" class="section-name selfRef">ECN-CE and L4S</a>
            </h5>
<p id="section-4.2.1.3-1">The ref_wnd is scaled down in proportion to the fraction of marked data units per
RTT. The scale down proportion is given by l4s_alpha, which is an EWMA filtered
version of the fraction of marked data units per RTT. This is inline with how DCTCP
works <span>[<a href="#RFC8257" class="cite xref">RFC8257</a>]</span>. Additional methods are applied to make the reference window
reduction reasonably stable, especially when the reference window is only a few
MSS. In addition, because SCReAMv2 can quite often be source limited, additional
steps are taken to restore the reference window to a proper value after a long
period without congestion.<a href="#section-4.2.1.3-1" class="pilcrow">¶</a></p>
<p id="section-4.2.1.3-2">l4s_alpha is calculated based in number of data units delivered (and marked).
This makes calculation of L4S alpha more accurate at very low bitrates, given that the tail data unit in e.g a video frame is often smaller than MSS.<a href="#section-4.2.1.3-2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.2.1.3-3.1">
                <p id="section-4.2.1.3-3.1.1">l4s_alpha (0.0): Average fraction of marked data units per RTT.<a href="#section-4.2.1.3-3.1.1" class="pilcrow">¶</a></p>
</li>
              <li class="normal" id="section-4.2.1.3-3.2">
                <p id="section-4.2.1.3-3.2.1">last_update_l4s_alpha_time (0): Last time l4s_alpha was updated [s].<a href="#section-4.2.1.3-3.2.1" class="pilcrow">¶</a></p>
</li>
              <li class="normal" id="section-4.2.1.3-3.3">
                <p id="section-4.2.1.3-3.3.1">data_units_delivered_this_rtt (0): Counter for delivered data units.<a href="#section-4.2.1.3-3.3.1" class="pilcrow">¶</a></p>
</li>
              <li class="normal" id="section-4.2.1.3-3.4">
                <p id="section-4.2.1.3-3.4.1">data_units_marked_this_rtt (0): Counter delivered and ECN-CE marked data units.<a href="#section-4.2.1.3-3.4.1" class="pilcrow">¶</a></p>
</li>
              <li class="normal" id="section-4.2.1.3-3.5">
                <p id="section-4.2.1.3-3.5.1">last_fraction_marked (0.0): fraction marked data units in last update<a href="#section-4.2.1.3-3.5.1" class="pilcrow">¶</a></p>
</li>
            </ul>
<p id="section-4.2.1.3-4">The following constant is used<a href="#section-4.2.1.3-4" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.2.1.3-5.1">
                <p id="section-4.2.1.3-5.1.1">L4S_AVG_G (1/16): Exponentially Weighted Moving Average (EWMA) factor for l4s_alpha<a href="#section-4.2.1.3-5.1.1" class="pilcrow">¶</a></p>
</li>
            </ul>
<div class="alignLeft art-text artwork" id="section-4.2.1.3-6">
<pre>
data_units_delivered_this_rtt += data_units_acked
data_units_marked_this_rtt += data_units_acked_ce
# l4s_alpha is updated at least every 10ms
if (now - last_update_l4s_alpha_time &gt;= min(0.01,s_rtt)
  # l4s_alpha is calculated from data_units marked istf bytes marked
  fraction_marked_t = data_units_marked_this_rtt/
                      data_units_delivered_this_rtt

  l4s_alpha = L4S_AVG_G*fraction_marked_t + (1.0-L4S_AVG_G)*l4S_alpha

  last_update_l4s_alpha_time = now
  data_units_delivered_this_rtt = 0
  data_units_marked_this_rtt = 0
  last_fraction_marked = fraction_marked_t
end
</pre><a href="#section-4.2.1.3-6" class="pilcrow">¶</a>
</div>
</section>
</div>
<div id="reaction-delay">
<section id="section-4.2.1.4">
            <h5 id="name-increased-queue-delay">
<a href="#section-4.2.1.4" class="section-number selfRef">4.2.1.4. </a><a href="#name-increased-queue-delay" class="section-name selfRef">Increased queue delay</a>
            </h5>
<p id="section-4.2.1.4-1">SCReAMv2 implements a delay-based congestion control approach where it mimics
L4S congestion marking when the averaged queue delay exceeds a target
threshold. This threshold is set to qdelay_target/2 and the congestion backoff
factor (l4s_alpha_v) increases linearly from 0 to 100% as qdelay_avg goes from
qdelay_target/2 to qdelay_target. The averaged qdelay (qdelay_avg) is used to
avoid that the SCReAMv2 congestion control over-reacts to scheduling jitter,
sudden delay spikes due to e.g. handover or link layer
retransmissions. Furthermore, the delay based congestion control is inactivated
when it is reasonably certain that L4S is active, i.e. L4S is enabled and
congested nodes apply L4S marking of data units. This reduces negative effects of
clockdrift, that the delay based control can introduce, whenever possible.<a href="#section-4.2.1.4-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.2.1.4-2.1">
                <p id="section-4.2.1.4-2.1.1">qdelay_avg:<a href="#section-4.2.1.4-2.1.1" class="pilcrow">¶</a></p>
</li>
            </ul>
<p id="section-4.2.1.4-3">The following constant is used:<a href="#section-4.2.1.4-3" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.2.1.4-4.1">
                <p id="section-4.2.1.4-4.1.1">QDELAY_AVG_G (1/4): Exponentially Weighted Moving Average (EWMA) factor for qdelay_avg<a href="#section-4.2.1.4-4.1.1" class="pilcrow">¶</a></p>
</li>
            </ul>
<div class="alignLeft art-text artwork" id="section-4.2.1.4-5">
<pre>
if (now - last_update_qdelay_avg_time &gt;= s_rtt)
  # qdelay_avg is updated with a slow attack, fast decay EWMA filter
  if (qdelay &lt; qdelay_avg)
    qdelay_avg = qdelay
  else
    qdelay_avg = QDELAY_AVG_G*qdelay + (1.0-QDELAY_AVG_G)*qdelay_avg
  end
  last_update_qdelay_avg_time = now
end
</pre><a href="#section-4.2.1.4-5" class="pilcrow">¶</a>
</div>
<div id="competing-flows-compensation">
<section id="section-4.2.1.4.1">
              <h6 id="name-competing-flows-compensatio">
<a href="#section-4.2.1.4.1" class="section-number selfRef">4.2.1.4.1. </a><a href="#name-competing-flows-compensatio" class="section-name selfRef">Competing Flows Compensation</a>
              </h6>
<p id="section-4.2.1.4.1-1">It is likely that a flow will have to share congested bottlenecks with other
flows that use a more aggressive congestion control algorithm (for example,
large FTP flows using loss-based congestion control). The worst condition occurs
when the bottleneck queues are of tail-drop type with a large buffer
size. SCReAMv2 takes care of such situations by adjusting the qdelay_target when
loss-based flows are detected, as shown in the pseudocode below.<a href="#section-4.2.1.4.1-1" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.2.1.4.1-2">
<pre>
adjust_qdelay_target(qdelay)
  qdelay_norm_t = qdelay / QDELAY_TARGET_LOW
  update_qdelay_norm_history(qdelay_norm_t)
  # Compute variance
  qdelay_norm_var_t = VARIANCE(qdelay_norm_history(200))
  # Compensation for competing traffic
  # Compute average
  qdelay_norm_avg_t = AVERAGE(qdelay_norm_history(50))
  # Compute upper limit to target delay
  new_target_t = qdelay_norm_avg_t + sqrt(qdelay_norm_var_t)
  new_target_t *= QDELAY_TARGET_LO
  if (loss_event_rate &gt; 0.002)
    # Data unit losses detected
    qdelay_target = 1.5 * new_target_t
  else
    if (qdelay_norm_var_t &lt; 0.2)
      # Reasonably safe to set target qdelay
      qdelay_target = new_target_t
    else
      # Check if target delay can be reduced; this helps prevent
      # the target delay from being locked to high values forever
      if (new_target_t &lt; QDELAY_TARGET_LO)
        # Decrease target delay quickly, as measured queuing
        # delay is lower than target
        qdelay_target = max(qdelay_target * 0.5, new_target_t)
      else
        # Decrease target delay slowly
        qdelay_target *= 0.9
      end
    end
  end

  # Apply limits
  qdelay_target = min(QDELAY_TARGET_HI, qdelay_target)
  qdelay_target = max(QDELAY_TARGET_LO, qdelay_target)
</pre><a href="#section-4.2.1.4.1-2" class="pilcrow">¶</a>
</div>
<p id="section-4.2.1.4.1-3">Two temporary variables are calculated. qdelay_norm_avg_t is the long-term
average queue delay, qdelay_norm_var_t is the long-term variance of the queue
delay. A high qdelay_norm_var_t indicates that the queue delay changes; this can
be an indication that bottleneck bandwidth is reduced or that a competing flow
has just entered. Thus, it indicates that it is not safe to adjust the queue
delay target.<a href="#section-4.2.1.4.1-3" class="pilcrow">¶</a></p>
<p id="section-4.2.1.4.1-4">A low qdelay_norm_var_t indicates that the queue delay is relatively stable. The
reason could be that the queue delay is low, but it could also be that a
competing flow is causing the bottleneck to reach the point that data unit losses
start to occur, in which case the queue delay will stay relatively high for a
longer time.<a href="#section-4.2.1.4.1-4" class="pilcrow">¶</a></p>
<p id="section-4.2.1.4.1-5">The queue delay target is allowed to be increased if either the loss event rate
is above a given threshold or qdelay_norm_var_t is low. Both these conditions
indicate that a competing flow may be present. In all other cases, the queue
delay target is decreased.<a href="#section-4.2.1.4.1-5" class="pilcrow">¶</a></p>
<p id="section-4.2.1.4.1-6">The function that adjusts the qdelay_target is simple and could produce false
positives and false negatives. The case that self-inflicted congestion by the
SCReAMv2 algorithm may be falsely interpreted as the presence of competing
loss-based FTP flows is a false positive. The opposite case -- where the
algorithm fails to detect the presence of a competing FTP flow -- is a false
negative.<a href="#section-4.2.1.4.1-6" class="pilcrow">¶</a></p>
<p id="section-4.2.1.4.1-7">Extensive simulations have shown that the algorithm performs well in LTE and 5G
test cases and that it also performs well in simple bandwidth-limited bottleneck
test cases with competing FTP flows. However, the potential failure of the
algorithm cannot be completely ruled out. A false positive (i.e., when
self-inflicted congestion is mistakenly identified as competing flows) is
especially problematic when it leads to increasing the target queue delay, which
can cause the end-to-end delay to increase dramatically.<a href="#section-4.2.1.4.1-7" class="pilcrow">¶</a></p>
<p id="section-4.2.1.4.1-8">If it is deemed unlikely that competing flows occur over the same bottleneck,
the algorithm described in this section MAY be turned off. One such case is
QoS-enabled bearers in 3GPP-based access such as LTE and 5G. However, when
sending over the Internet, often the network conditions are not known for sure,
so in general it is not possible to make safe assumptions on how a network is
used and whether or not competing flows share the same bottleneck. Therefore,
turning this algorithm off must be considered with caution, as it can lead to
basically zero throughput if competing with loss-based traffic.<a href="#section-4.2.1.4.1-8" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
</section>
</div>
<div id="ref-wnd-update">
<section id="section-4.2.2">
          <h4 id="name-reference-window-update">
<a href="#section-4.2.2" class="section-number selfRef">4.2.2. </a><a href="#name-reference-window-update" class="section-name selfRef">Reference Window Update</a>
          </h4>
<p id="section-4.2.2-1">The reference window update contains two parts. One that reduces the reference
window when congestion events (listed above) occur, and one part that
continously increases the reference window.<a href="#section-4.2.2-1" class="pilcrow">¶</a></p>
<p id="section-4.2.2-2">The following variables are defined:<a href="#section-4.2.2-2" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.2.2-3.1">
              <p id="section-4.2.2-3.1.1">ref_wnd (MIN_REF_WND): Reference window [byte].<a href="#section-4.2.2-3.1.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-4.2.2-3.2">
              <p id="section-4.2.2-3.2.1">ref_wnd_i (1): Reference window inflection point [byte].<a href="#section-4.2.2-3.2.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-4.2.2-3.3">
              <p id="section-4.2.2-3.3.1">max_bytes_in_flight (0): The maximum number of bytes in flight in the last
round trip [byte].<a href="#section-4.2.2-3.3.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-4.2.2-3.4">
              <p id="section-4.2.2-3.4.1">max_bytes_in_flight_prev (0): The maximum number of bytes in flight in
previous round trip [byte].<a href="#section-4.2.2-3.4.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-4.2.2-3.5">
              <p id="section-4.2.2-3.5.1">qdelay_target (QDELAY_TARGET_LO): qdelay target [s], a variable qdelay target
is introduced to manage cases where a fixed qdelay target would otherwise
starve the data flow under such circumstances (e.g., FTP competes for the
bandwidth over the same bottleneck). The qdelay target is allowed to vary
between QDELAY_TARGET_LO and QDELAY_TARGET_HI.<a href="#section-4.2.2-3.5.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-4.2.2-3.6">
              <p id="section-4.2.2-3.6.1">last_congestion_detected_time (0): Last time congestion event occured [s].<a href="#section-4.2.2-3.6.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-4.2.2-3.7">
              <p id="section-4.2.2-3.7.1">last_ref_wnd_i_update_time (0): Last time ref_wnd_i was updated [s].<a href="#section-4.2.2-3.7.1" class="pilcrow">¶</a></p>
</li>
          </ul>
<p id="section-4.2.2-4">Further the following constants are used (the RECOMMENDED values, within parentheses "()",
for the constants are deduced from experiments):<a href="#section-4.2.2-4" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.2.2-5.1">
              <p id="section-4.2.2-5.1.1">QDELAY_TARGET_LO (0.06): Target value for the minimum qdelay [s].<a href="#section-4.2.2-5.1.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-4.2.2-5.2">
              <p id="section-4.2.2-5.2.1">QDELAY_TARGET_HI (0.4): Target value for the maximum qdelay [s]. This
parameter provides an upper limit to how much the target qdelay
(qdelay_target) can be increased in order to cope with competing loss-based
flows. However, the target qdelay does not have to be initialized to this high
value, as it would increase end-to-end delay and also make the rate control
and congestion control loops sluggish.<a href="#section-4.2.2-5.2.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-4.2.2-5.3">
              <p id="section-4.2.2-5.3.1">MIN_REF_WND (3000): Minimum reference window [byte].<a href="#section-4.2.2-5.3.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-4.2.2-5.4">
              <p id="section-4.2.2-5.4.1">BYTES_IN_FLIGHT_HEAD_ROOM (2.0): Extra headroom for bytes in flight.<a href="#section-4.2.2-5.4.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-4.2.2-5.5">
              <p id="section-4.2.2-5.5.1">BETA_LOSS (0.7): ref_wnd scale factor due to loss event.<a href="#section-4.2.2-5.5.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-4.2.2-5.6">
              <p id="section-4.2.2-5.6.1">BETA_ECN (0.8): ref_wnd scale factor due to ECN event.<a href="#section-4.2.2-5.6.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-4.2.2-5.7">
              <p id="section-4.2.2-5.7.1">MSS (1000): Maximum segment size = Max data unit size [byte].<a href="#section-4.2.2-5.7.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-4.2.2-5.8">
              <p id="section-4.2.2-5.8.1">REF_WND_OVERHEAD (1.5): Indicates how much bytes in flight is allowed to
exceed ref_wnd.<a href="#section-4.2.2-5.8.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-4.2.2-5.9">
              <p id="section-4.2.2-5.9.1">POST_CONGESTION_DELAY_RTT (100): Determines how many RTTs after a congestion
event the reference window growth should be cautious.<a href="#section-4.2.2-5.9.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-4.2.2-5.10">
              <p id="section-4.2.2-5.10.1">MUL_INCREASE_FACTOR (0.02): Determines how much (as a fraction of ref_wnd)
that the ref_wnd can increase per RTT.<a href="#section-4.2.2-5.10.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-4.2.2-5.11">
              <p id="section-4.2.2-5.11.1">IS_L4S (false): Congestion control operates in L4S mode.<a href="#section-4.2.2-5.11.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-4.2.2-5.12">
              <p id="section-4.2.2-5.12.1">VIRTUAL_RTT (0.025): Virtual RTT [s]. This mimics Prague's RTT fairness such that flows with RTT
below VIRTUAL_RTT should get a roughly equal share over an L4S path.<a href="#section-4.2.2-5.12.1" class="pilcrow">¶</a></p>
</li>
          </ul>
<div id="reference-window-reduction">
<section id="section-4.2.2.1">
            <h5 id="name-reference-window-reduction">
<a href="#section-4.2.2.1" class="section-number selfRef">4.2.2.1. </a><a href="#name-reference-window-reduction" class="section-name selfRef">reference window reduction</a>
            </h5>
<div class="alignLeft art-text artwork" id="section-4.2.2.1-1">
<pre>
# The reference window is updated at least every VIRTUAL_RTT
if (now - last_congestion_detected_time &gt;= min(VIRTUAL_RTT,s_rtt)
  if (loss detected)
    is_loss_t = true
  end
  if (data units marked)
    is_ce_t = true
  end
  if (qdelay &gt; qdelay_target/2)
    # It is expected that l4s_alpha is below a given value,
    l4_alpha_lim_t = 2 / target_bitrate * MSS * 8 / s_rtt
    if (l4s_alpha &lt; l4_alpha_lim_t || !l4s_active)
      # L4S does not seem to be active
      l4s_alpha_v_t = min(1.0, max(0.0,
         (qdelay_avg - qdelay_target / 2) /
         (qdelay_target / 2)));
      is_virtual_ce_t = true
    end
  end
end

if (is_loss_t || is_ce_t || is_virtual_ce_t)
  if (now - last_ref_wnd_i_update_time &gt; 10*s_rtt)
    # Update ref_wnd_i, no more often than every 10 RTTs
    # Additional median filtering over more congestion epochs
    # may improve accuracy of ref_wnd_i
    last_ref_wnd_i_update_time = now
    ref_wnd_i = ref_wnd
  end
end


# Either loss, ECN mark or increased qdelay is detected
if (is_loss_t)
  # Loss is detected
  ref_wnd = ref_wnd * BETA_LOSS
end
if (is_ce_t)
  # ECN-CE detected
  if (IS_L4S)
    # L4S mode
    backoff_t = l4s_alpha / 2

    # Increase stability for very small ref_wnd
    backOff_t *= max(0.5, 1.0 - ref_wnd_ratio)

    if (now - last_congestion_detected_time &gt;
        100*max(VIRTUAL_RTT,s_rtt))
      # A long time (&gt;100 RTTs) since last congested because
      # link throughput exceeds max video bitrate.
      # There is a certain risk that ref_wnd has increased way above
      # bytes in flight, so we reduce it here to get it better on
      # track and thus the congestion episode is shortened
      ref_wnd = min(ref_wnd, max_bytes_in_flight_prev)

      # Also, we back off a little extra if needed
      # because alpha is quite likely very low
      # This can in some cases be an over-reaction
      # but as this function should kick in relatively seldom
      # it should not be to too big concern
      backoff_t = max(backoff_t, 0.25)

      # In addition, bump up l4sAlpha to a more credible value
      # This may over react but it is better than
      # excessive queue delay
      l4sAlpha = 0.25
    end
    ref_wnd = (1.0 - backoff_t) * ref_wnd
  else
    # Classic ECN mode
    ref_wnd = ref_wnd * BETA_ECN
  end
end
if (is_virtual_ce_t)
  backoff_t = l4s_alpha_v_t / 2
  ref_wnd = (1.0 - backoff_t) * ref_wnd
end
ref_wnd = max(MIN_REF_WND, ref_wnd)

if (is_loss_t || is_ce_t || is_virtual_ce_t)
  last_congestion_detected_time = now
end
</pre><a href="#section-4.2.2.1-1" class="pilcrow">¶</a>
</div>
<p id="section-4.2.2.1-2">The variable max_bytes_in_flight_prev indicates the maximum bytes in flights in
the previous round trip. The reason to this is that bytes in flight can spike
when congestion occurs, max_bytes_in_flight_prev thus ensures better that an
uncongested bytes in flight is used.<a href="#section-4.2.2.1-2" class="pilcrow">¶</a></p>
</section>
</div>
<div id="reference-window-increase">
<section id="section-4.2.2.2">
            <h5 id="name-reference-window-increase">
<a href="#section-4.2.2.2" class="section-number selfRef">4.2.2.2. </a><a href="#name-reference-window-increase" class="section-name selfRef">Reference window increase</a>
            </h5>
<div class="alignLeft art-text artwork" id="section-4.2.2.2-1">
<pre>
# Delay factor for multiplicative reference window increase
# after congestion

post_congestion_scale_t = max(0.0, min(1.0,
 (now - last_congestion_detected_time) /
  (POST_CONGESTION_DELAY_RTTS * max(VIRTUAL_RTT, s_rtt))))

# Scale factor for ref_wnd update
ref_wnd_scale_factor_t = 1.0 + (MUL_INCREASE_FACTOR  * ref_wnd) / MSS)


# Calculate bytes acked that are not CE marked
# For the case that only accumulated number of CE marked packets is
# reported by the feedback, it is necessary to make an approximation
# of bytes_newly_acked_ce based on average data unit size.
bytes_newly_acked_minus_ce_t = bytes_newly_acked-
                               bytes_newly_acked_ce

increment_t = bytes_newly_acked_minus_ce_t*ref_wnd_ratio

# Reduce increment for small RTTs
tmp_t = min(1.0, s_rtt / VIRTUAL_RTT)
increment_t *= tmp_t * tmp_t

# Apply limit to reference window growth when close to last
# known max value before congestion
scl_t = (ref_wnd-ref_wnd_i) / ref_wnd_i
scl_t *= 4
scl_t = scl_t * scl_t
scl_t = max(0.1, min(1.0, scl_t))
if (!is_l4s_active)
  increment_t *= scl_t
end

# Limit on CWND growth speed further for small CWND
# This is complemented with a corresponding restriction on CWND
# reduction
increment_t *= max(0.5,1.0-ref_wnd_ratio)

# Scale up increment with multiplicative increase
# Limit multiplicative increase when congestion occured
# recently and when reference window is close to the last
# known max value
float tmp_t = ref_wnd_scale_factor_t
if (tmp_t &gt; 1.0)
  tmp_t = 1.0 + (tmp_t - 1.0) * post_congestion_scale_t * scl_t;
end
increment *= tmp_t

# Increase ref_wnd only if bytes in flight is large enough
# Quite a lot of slack is allowed here to avoid that bitrate
# locks to low values.
max_allowed_t = MSS + max(max_bytes_in_flight,
  max_bytes_in_flight_prev) * BYTES_IN_FLIGHT_HEAD_ROOM
int ref_wnd_t = ref_wnd + increment_t
if (ref_wnd_t &lt;= max_allowed_t)
  ref_wnd = ref_wnd_t
end
</pre><a href="#section-4.2.2.2-1" class="pilcrow">¶</a>
</div>
<p id="section-4.2.2.2-2">The ref_wnd_scale_factor_t scales the reference window increase. The
ref_wnd_scale_factor_t is increased with larger ref_wnd to allow for a
multiplicative increase and thus a faster convergence when link capacity
increases.<a href="#section-4.2.2.2-2" class="pilcrow">¶</a></p>
<p id="section-4.2.2.2-3">The variable max_bytes_in_flight indicates the max bytes in flight in the
current round trip.<a href="#section-4.2.2.2-3" class="pilcrow">¶</a></p>
<p id="section-4.2.2.2-4">The multiplicative increase is restricted directly after a congestion event and
the restriction is gradually relaxed as the time since last congested
increased. The restriction makes the reference window growth to be no faster
than additive increase when congestion continusly occurs.  For L4S operation
this means that the SCReAMv2 algorithm will adhere to the 2 marked data units per
RTT equilibrium at steady state congestion, with the exception of the case
below.<a href="#section-4.2.2.2-4" class="pilcrow">¶</a></p>
<p id="section-4.2.2.2-5">The reference window increase is restricted to values as small as 0.1MSS/RTT
when the reference window is close to the last known max value (ref_wnd_i). This
increases stability and reduces periodic overshoot. This restriction is applied
in full only for small reference windows when in L4S operation.<a href="#section-4.2.2.2-5" class="pilcrow">¶</a></p>
<p id="section-4.2.2.2-6">It is particularly important that the reference window reflects the transmitted
bitrate especially in L4S mode operation. An inflated ref_wnd takes extra RTTs
to bring down to a correct value upon congestion and thus causes unnecessary
queue buildup. At the same time the reference window must be allowed to be large
enough to avoid that the SCReAMv2 algorithm begins to limit itself, given that
the target bitrate is calculated based on the ref_wnd. Two mechanisms are used
to manage this:<a href="#section-4.2.2.2-6" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.2.2.2-7.1">
                <p id="section-4.2.2.2-7.1.1">Restore correct value of ref_wnd upon congestion. This is done if is a
prolonged time since the link was congested. A typical example is that
SCReAMv2 has been rate limited, i.e the target bitrate has reached the
TARGET_BITRATE_MAX.<a href="#section-4.2.2.2-7.1.1" class="pilcrow">¶</a></p>
</li>
              <li class="normal" id="section-4.2.2.2-7.2">
                <p id="section-4.2.2.2-7.2.1">Limit ref_wnd when the target_bitrate has reached TARGET_BITRATE_MAX. The
ref_wnd is restricted based on a history of the last max_bytes_in_flight
values. See <span>[<a href="#SCReAM-CPP-implementation" class="cite xref">SCReAM-CPP-implementation</a>]</span> for details.<a href="#section-4.2.2.2-7.2.1" class="pilcrow">¶</a></p>
</li>
            </ul>
<p id="section-4.2.2.2-8">The two mechanisms complement one another.<a href="#section-4.2.2.2-8" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
</section>
</div>
<div id="sender-transmission-control">
<section id="section-4.3">
        <h3 id="name-sender-transmission-control-2">
<a href="#section-4.3" class="section-number selfRef">4.3. </a><a href="#name-sender-transmission-control-2" class="section-name selfRef">Sender Transmission Control</a>
        </h3>
<p id="section-4.3-1">The Sender Transmission control calculates of send window at the sender.
Data units are transmitted if allowed by the relation between the number of bytes
in flight and the reference window. This is controlled by the send window:<a href="#section-4.3-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.3-2.1">
            <p id="section-4.3-2.1.1">send_wnd (0): Upper limit to how many bytes can currently be
transmitted. Updated when ref_wnd is updated and when data unit is
transmitted [byte].<a href="#section-4.3-2.1.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<div id="send-window">
<section id="section-4.3.1">
          <h4 id="name-send-window-calculation">
<a href="#section-4.3.1" class="section-number selfRef">4.3.1. </a><a href="#name-send-window-calculation" class="section-name selfRef">Send Window Calculation</a>
          </h4>
<p id="section-4.3.1-1">The basic design principle behind data unit transmission in SCReAM was to allow
transmission only if the number of bytes in flight is less than the congestion
window. There are, however, two reasons why this strict rule will not work
optimally:<a href="#section-4.3.1-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.3.1-2.1">
              <p id="section-4.3.1-2.1.1">Bitrate variations: Media sources such as video encoders generally produce
frames whose size always vary to a larger or smaller extent. The data unit queue
absorbs the natural variations in frame sizes. However, the data unit queue should
be as short as possible to prevent the end-to-end delay from increasing. A
strict 'send only when bytes in flight is less than the reference window' rule
can cause the data unit queue to grow simply because the send window is limited. The
consequence is that the reference window will not increase, or will increase
very slowly, because the reference window is only allowed to increase when
there is a sufficient amount of data in flight. The final effect is that the
media bitrate increases very slowly or not at all.<a href="#section-4.3.1-2.1.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-4.3.1-2.2">
              <p id="section-4.3.1-2.2.1">Reverse (feedback) path congestion: Especially in transport over
buffer-bloated networks, the one-way delay in the reverse direction can jump
due to congestion. The effect is that the acknowledgements are delayed, and
the self-clocking is temporarily halted, even though the forward path is not
congested. The REF_WND_OVERHEAD allows for some degree of reverse path
congestion as the bytes in flight is allowed to exceed ref_wnd.<a href="#section-4.3.1-2.2.1" class="pilcrow">¶</a></p>
</li>
          </ul>
<p id="section-4.3.1-3">In SCReAMv2, the send window is given by the relation between the adjusted
reference window and the amount of bytes in flight according to the pseudocode
below. The multiplication of ref_wnd with REF_WND_OVERHEAD and
rel_framesize_high has the effect that bytes in flight is 'around' the ref_wnd
rather than limited by the ref_wnd when the link is congested.  The
implementation allows the data unit queue to be small even when the frame sizes vary
and thus increased e2e delay can be avoided.<a href="#section-4.3.1-3" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.3.1-4">
<pre>
send_wnd = ref_wnd * REF_WND_OVERHEAD * rel_framesize_high -
           bytes_in_flight
</pre><a href="#section-4.3.1-4" class="pilcrow">¶</a>
</div>
<p id="section-4.3.1-5">The send window is updated whenever an data unit is transmitted or an feedback
messaged is received.<a href="#section-4.3.1-5" class="pilcrow">¶</a></p>
<p id="section-4.3.1-6">The variable rel_framesize_high is based on calculation of the high percentile
of the frame sizes. The calculation is based on a histogram of the frame sizes
relative to the expected frame size given the target bitrate and frame
period. The calculation of rel_framesize_high is done for every new video frame
and is outlined roughly with the pseudo code below. For more detailed code, see
<span>[<a href="#SCReAM-CPP-implementation" class="cite xref">SCReAM-CPP-implementation</a>]</span>.<a href="#section-4.3.1-6" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.3.1-7.1">
              <p id="section-4.3.1-7.1.1">rel_framesize_high (1.0): High percentile of frame size, normalized by nominal
frame size for the given target bitrate<a href="#section-4.3.1-7.1.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-4.3.1-7.2">
              <p id="section-4.3.1-7.2.1">frame_period (0.02): The frame period [s].<a href="#section-4.3.1-7.2.1" class="pilcrow">¶</a></p>
</li>
          </ul>
<div class="alignLeft art-text artwork" id="section-4.3.1-8">
<pre>
# frame_size is that frame size for the last encoded frame
tmp_t = frame_size / (target_bitrate * frame_period / 8)

if (tmp_t &gt; 1.0)
  # Insert sample into histogram
  insert_into_histogram(tmp_t)
  # Get high percentile
  rel_framesize_high = get_histogram_high_percentile()
end
</pre><a href="#section-4.3.1-8" class="pilcrow">¶</a>
</div>
<p id="section-4.3.1-9">A 75%-ile is used in <span>[<a href="#SCReAM-CPP-implementation" class="cite xref">SCReAM-CPP-implementation</a>]</span>, the histogram can be made
leaky such that old samples are gradually forgotten.<a href="#section-4.3.1-9" class="pilcrow">¶</a></p>
</section>
</div>
<div id="packet-pacing">
<section id="section-4.3.2">
          <h4 id="name-packet-pacing">
<a href="#section-4.3.2" class="section-number selfRef">4.3.2. </a><a href="#name-packet-pacing" class="section-name selfRef">Packet Pacing</a>
          </h4>
<p id="section-4.3.2-1">Packet pacing is used in order to mitigate coalescing, i.e., when packets are
transmitted in bursts, with the risks of increased jitter and potentially
increased packet loss. Packet pacing is also recommended to be used with L4S and
also mitigates possible issues with queue overflow due to key-frame generation
in video coders.<a href="#section-4.3.2-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.3.2-2.1">
              <p id="section-4.3.2-2.1.1">pace_bitrate (1e6): Data unit pacing rate [bps].<a href="#section-4.3.2-2.1.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-4.3.2-2.2">
              <p id="section-4.3.2-2.2.1">t_pace (1e-6): Pacing interval between data units [s].<a href="#section-4.3.2-2.2.1" class="pilcrow">¶</a></p>
</li>
          </ul>
<p id="section-4.3.2-3">The following constants are used by the packet pacing:<a href="#section-4.3.2-3" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.3.2-4.1">
              <p id="section-4.3.2-4.1.1">RATE_PACE_MIN (50000): Minimum pacing rate in [bps].<a href="#section-4.3.2-4.1.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-4.3.2-4.2">
              <p id="section-4.3.2-4.2.1">PACKET_PACING_HEADROOM (1.5): Extra head room for packet pacing.<a href="#section-4.3.2-4.2.1" class="pilcrow">¶</a></p>
</li>
          </ul>
<p id="section-4.3.2-5">The time interval between consecutive data unit transmissions is
greater than or equal to t_pace, where t_pace is given by the equations below:<a href="#section-4.3.2-5" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.3.2-6">
<pre>
pace_bitrate = max(RATE_PACE_MIN, target_bitrate) *
               PACKET_PACING_HEADROOM
t_pace = data_unit_size * 8 / pace_bitrate
</pre><a href="#section-4.3.2-6" class="pilcrow">¶</a>
</div>
<p id="section-4.3.2-7">data_unit_size is the size of the last transmitted data unit. RATE_PACE_MIN is the
minimum pacing rate.<a href="#section-4.3.2-7" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
<div id="media-rate-control-2">
<section id="section-4.4">
        <h3 id="name-media-rate-control-2">
<a href="#section-4.4" class="section-number selfRef">4.4. </a><a href="#name-media-rate-control-2" class="section-name selfRef">Media Rate Control</a>
        </h3>
<p id="section-4.4-1">The media rate control algorithm is executed whenever the reference window is
updated and calculates the target bitrate:<a href="#section-4.4-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.4-2.1">
            <p id="section-4.4-2.1.1">target_bitrate (0): Media target bitrate [bps].<a href="#section-4.4-2.1.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-4.4-3">The following constants are used by the media rate control:<a href="#section-4.4-3" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.4-4.1">
            <p id="section-4.4-4.1.1">BYTES_IN_FLIGHT_LIMIT<a href="#section-4.4-4.1.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-4.4-4.2">
            <p id="section-4.4-4.2.1">BYTES_IN_FLIGHT_LIMIT_COMPENSATION<a href="#section-4.4-4.2.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-4.4-4.3">
            <p id="section-4.4-4.3.1">PACKET_OVERHEAD (20) : Estimated packetization overhead [byte]<a href="#section-4.4-4.3.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-4.4-4.4">
            <p id="section-4.4-4.4.1">TARGET_BITRATE_MIN: Minimum target bitrate in [bps] (bits per second).<a href="#section-4.4-4.4.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-4.4-4.5">
            <p id="section-4.4-4.5.1">TARGET_BITRATE_MAX: Maximum target bitrate in [bps].<a href="#section-4.4-4.5.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-4.4-5">The target bitrate is essentiatlly based
on the reference window ref_wnd and the (smoothed) RTT s_rtt according to<a href="#section-4.4-5" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.4-6">
<pre>
target_bitrate = 8 * ref_wnd / s_rtt
</pre><a href="#section-4.4-6" class="pilcrow">¶</a>
</div>
<p id="section-4.4-7">The role of the media rate control is to strike a reasonable balance between a
low amount of queuing in the data unit queue(s) and a sufficient amount of data to
send in order to keep the data path busy. Because the reference window is
updated based on loss, ECN-CE and delay, so does the target rate also update.<a href="#section-4.4-7" class="pilcrow">¶</a></p>
<p id="section-4.4-8">The code above however needs some modifications to work fine in a number of
scenarios<a href="#section-4.4-8" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-4.4-9.1">
            <p id="section-4.4-9.1.1">L4S is inactive, i.e L4S is either not enabled or congested bottlenecks do not
L4S mark data units<a href="#section-4.4-9.1.1" class="pilcrow">¶</a></p>
</li>
          <li class="normal" id="section-4.4-9.2">
            <p id="section-4.4-9.2.1">ref_wnd is very small, just a few MSS or smaller<a href="#section-4.4-9.2.1" class="pilcrow">¶</a></p>
</li>
        </ul>
<p id="section-4.4-10">The complete pseudo code for adjustment of the target bitrate is shown below<a href="#section-4.4-10" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-4.4-11">
<pre>
tmp_t = 1.0

# limit bitrate if bytes in flight exceeds is close to or
# exceeds ref_wnd. This helps to avoid large rate fluctiations and
# variations in RTT
# Only applied when L4S is inactive
if (!l4s_active &amp;&amp; bytes_in_flight_ratio &gt; BYTES_IN_FLIGHT_LIMIT)
  tmp_t /= min(BYTES_IN_FLIGHT_LIMIT_COMPENSATION,
    bytesInFlightRatio / BYTES_IN_FLIGHT_LIMIT)
end

# Scale down rate slighty when the reference window is very
# small compared to MSS
tmp_t *= 1.0 - min(0.2, max(0.0, ref_wnd_ratio - 0.1))

# Additional compensation for packetization overhead,
# important when MSS is small
tmp_t_ *= mss/(mss + PACKET_OVERHEAD)

# Calculate target bitrate and limit to min and max allowed
# values
target_bitrate = tmp_t * 8 * ref_wnd / s_rtt
target_bitrate = min(TARGET_BITRATE_MAX,
  max(TARGET_BITRATE_MIN,target_bitrate))
</pre><a href="#section-4.4-11" class="pilcrow">¶</a>
</div>
<div id="coder-errors">
<section id="section-4.4.1">
          <h4 id="name-handling-of-systematic-erro">
<a href="#section-4.4.1" class="section-number selfRef">4.4.1. </a><a href="#name-handling-of-systematic-erro" class="section-name selfRef">Handling of systematic errors in video coders</a>
          </h4>
<p id="section-4.4.1-1">Some video encoders are prone to systematically generate an output bitrate that
is systematically larger or smaller than the target bitrate. SCReAMv2 can handle
some deviation inherently but for larger devation it becomes necessary to
compensate for this. The algorithm for this is detailed in
<span>[<a href="#SCReAM-CPP-implementation" class="cite xref">SCReAM-CPP-implementation</a>]</span>.<a href="#section-4.4.1-1" class="pilcrow">¶</a></p>
<p id="section-4.4.1-2">ToDo: A future draft version will describe this in more detail as it has been
fully integrated into SCReAMv2.<a href="#section-4.4.1-2" class="pilcrow">¶</a></p>
</section>
</div>
</section>
</div>
</section>
</div>
<div id="scream-receiver">
<section id="section-5">
      <h2 id="name-receiver-requirements-on-fe">
<a href="#section-5" class="section-number selfRef">5. </a><a href="#name-receiver-requirements-on-fe" class="section-name selfRef">Receiver Requirements on Feedback Intensity</a>
      </h2>
<p id="section-5-1">The simple task of the receiver is to feed back acknowledgements with with time
stamp and ECN bits indication for received data units to the sender. Upon reception
of each data unit, the receiver MUST maintain enough information to send the
aforementioned values to the sender via an RTCP transport- layer feedback
message. The frequency of the feedback message depends on the available RTCP
bandwidth. The requirements on the feedback elements and the feedback interval
are described below.<a href="#section-5-1" class="pilcrow">¶</a></p>
<p id="section-5-2">SCReAMv2 benefits from relatively frequent feedback. It is RECOMMENDED that a
SCReAMv2 implementation follows the guidelines below.<a href="#section-5-2" class="pilcrow">¶</a></p>
<p id="section-5-3">The feedback interval depends on the media bitrate. At low bitrates, it is
sufficient with a feedback every frame; while at high bitrates, a feedback
interval of roughly 5ms is preferred. At very high bitrates, even shorter
feedback intervals MAY be needed in order to keep the self-clocking in SCReAMv2
working well. One indication that feedback is too sparse is that the SCReAMv2
implementation cannot reach high bitrates, even in uncongested links. More
frequent feedback might solve this issue.<a href="#section-5-3" class="pilcrow">¶</a></p>
<p id="section-5-4">The numbers above can be formulated as a feedback interval function that can be
useful for the computation of the desired RTCP bandwidth. The following equation
expresses the feedback rate:<a href="#section-5-4" class="pilcrow">¶</a></p>
<div class="alignLeft art-text artwork" id="section-5-5">
<pre>
# Assume 100 byte feedback packets
rate_fb = 0.02 * [average received rate] / (100.0 * 8.0);
rate_fb = min(1000, max(10, rate_fb))

# Calculate feedback intervals
fb_int = 1.0/rate_fb
</pre><a href="#section-5-5" class="pilcrow">¶</a>
</div>
<p id="section-5-6">Feedback should also forcibly be transmitted in any of these cases:<a href="#section-5-6" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-5-7.1">
          <p id="section-5-7.1.1">More than N data units received since last feedback has been transmitted<a href="#section-5-7.1.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-5-7.2">
          <p id="section-5-7.2.1">A data unit with marker bit set or other last data unit for media frame is received<a href="#section-5-7.2.1" class="pilcrow">¶</a></p>
</li>
      </ul>
<p id="section-5-8">The transmission interval is not critical. So, in the case of multi-stream
handling between two hosts, the feedback for two or more synchronization sources
(SSRCs) can be bundled to save UDP/IP overhead. However, the final realized
feedback interval SHOULD NOT exceed 2*fb_int in such cases, meaning that a
scheduled feedback transmission event should not be delayed more than fb_int.<a href="#section-5-8" class="pilcrow">¶</a></p>
<p id="section-5-9">SCReAMv2 works with AVPF regular mode; immediate or early mode is not required
by SCReAMv2 but can nonetheless be useful for RTCP messages not directly related
to SCReAMv2, such as those specified in <span>[<a href="#RFC4585" class="cite xref">RFC4585</a>]</span>. It is RECOMMENDED to use
reduced-size RTCP <span>[<a href="#RFC5506" class="cite xref">RFC5506</a>]</span>, where regular full compound RTCP transmission is
controlled by trr-int as described in <span>[<a href="#RFC4585" class="cite xref">RFC4585</a>]</span>.<a href="#section-5-9" class="pilcrow">¶</a></p>
<p id="section-5-10">While the guidelines above are somewhat RTCP specific, similar principles apply
to for instance QUIC.<a href="#section-5-10" class="pilcrow">¶</a></p>
</section>
</div>
<div id="discussion">
<section id="section-6">
      <h2 id="name-discussion">
<a href="#section-6" class="section-number selfRef">6. </a><a href="#name-discussion" class="section-name selfRef">Discussion</a>
      </h2>
<p id="section-6-1">This section covers a few discussion points.<a href="#section-6-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6-2.1">
          <p id="section-6-2.1.1">Clock drift: SCReAM/SCReAMv2 can suffer from the same issues with clock drift
as is the case with LEDBAT <span>[<a href="#RFC6817" class="cite xref">RFC6817</a>]</span>. However, Appendix A.2 in <span>[<a href="#RFC6817" class="cite xref">RFC6817</a>]</span>
describes ways to mitigate issues with clock drift. A clockdrift compensation
method is also implemented in <span>[<a href="#SCReAM-CPP-implementation" class="cite xref">SCReAM-CPP-implementation</a>]</span>. Furthermore, the
SCReAM implementation resets base delay history when it is determined that
clock drift becomes too large. This is achieved by reducing the target bitrate
for a few RTTs.<a href="#section-6-2.1.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-6-2.2">
          <p id="section-6-2.2.1">Clock skipping: The sender or receiver clock can occasionally skip. Handling
of this is implemented in <span>[<a href="#SCReAM-CPP-implementation" class="cite xref">SCReAM-CPP-implementation</a>]</span>.<a href="#section-6-2.2.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-6-2.3">
          <p id="section-6-2.3.1">The target bitrate given by SCReAMv2 is the bitrate including the data unit and
Forward Error Correction (FEC) overhead. The media encoder SHOULD take this
overhead into account when the media bitrate is set. This means that the media
coder bitrate SHOULD be computed as: media_rate = target_bitrate -
data_unit_plus_fec_overhead_bitrate It is not necessary to make a 100% perfect
compensation for the overhead, as the SCReAM algorithm will inherently
compensate for moderate errors. Under-compensating for the overhead has the
effect of increasing jitter, while overcompensating will cause the bottleneck
link to become underutilized.<a href="#section-6-2.3.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-6-2.4">
          <p id="section-6-2.4.1">The link utilization with SCReAMv2 can be lower than 100%. There are several
possible reasons to this:<a href="#section-6-2.4.1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-6-2.4.2.1">
              <p id="section-6-2.4.2.1.1">Large variations in frame sizes: Large variations in frame size makes
SCReAMv2 push down the target_bitrate to give sufficient headroom and avoid
queue buildup in the network. It is in general recommended to operate video
coders in low latency mode and enable GDR (Gradual Decoding Refresh) if
possible to minimize frame size variations.<a href="#section-6-2.4.2.1.1" class="pilcrow">¶</a></p>
</li>
            <li class="normal" id="section-6-2.4.2.2">
              <p id="section-6-2.4.2.2.1">Link layer properties: Media transport in 5G in uplink typically requires to
transmit a scheduling request (SR) to get persmission to transmit
data. Because transmission of video is frame based, there is a high
likelihood that the channel becomes idle between frames (especially with
L4S), in which case a new SR/grant exchange is needed. This potentially
means that uplink transmission slots are unused with a lower link
utilization as a result.<a href="#section-6-2.4.2.2.1" class="pilcrow">¶</a></p>
</li>
          </ul>
</li>
        <li class="normal" id="section-6-2.5">
          <p id="section-6-2.5.1">Packet pacing is recommended, it is however possible to operate SCReAMv2 with
  packet pacing disabled. The code in <span>[<a href="#SCReAM-CPP-implementation" class="cite xref">SCReAM-CPP-implementation</a>]</span> implements
  additonal mechanisms to achieve a high link utilization when packet pacing is
  disabled.<a href="#section-6-2.5.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-6-2.6">
          <p id="section-6-2.6.1">Feedback issues: RTCP feedback packets <span>[<a href="#RFC8888" class="cite xref">RFC8888</a>]</span> can be lost, this means that
  the loss detection in SCReAMv2 may trigger even though packets arrive safely
  on the receiver side. <span>[<a href="#SCReAM-CPP-implementation" class="cite xref">SCReAM-CPP-implementation</a>]</span> solves this by using
  overlapping RTCP feedback, i.e RTCP feedback is transmitted no more seldom
  than every 16th packet, and where each RTCP feedback spans the last 32
  received packets. This however creates unnecessary overhead. <span>[<a href="#RFC3550" class="cite xref">RFC3550</a>]</span> RR
  (Receiver Reports) can possibly be another solution to achieve better
  robustness with less overhead. QUIC <span>[<a href="#RFC9000" class="cite xref">RFC9000</a>]</span> overcomes this issue because
  of inherent design.<a href="#section-6-2.6.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-6-2.7">
          <p id="section-6-2.7.1">SCReAM has over time been evaluated in a number of different experiments, a
  few examples are found in <span>[<a href="#SCReAM-evaluation-L4S" class="cite xref">SCReAM-evaluation-L4S</a>]</span>.<a href="#section-6-2.7.1" class="pilcrow">¶</a></p>
</li>
      </ul>
</section>
</div>
<div id="algorithm-changes">
<section id="section-7">
      <h2 id="name-algorithm-changes">
<a href="#section-7" class="section-number selfRef">7. </a><a href="#name-algorithm-changes" class="section-name selfRef">Algorithm changes</a>
      </h2>
<p id="section-7-1">The algorithm has changed quite considerably since <span>[<a href="#RFC8298" class="cite xref">RFC8298</a>]</span>. The main changes are:<a href="#section-7-1" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7-2.1">
          <p id="section-7-2.1.1">L4S support added. The L4S algoritm has many similarities with the DCTCP and
Prague congestion control but has a few extra modifications to make it work
well with peridic sources such as video.<a href="#section-7-2.1.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-7-2.2">
          <p id="section-7-2.2.1">The delay based congestion control is changed to implement a pseudo-L4S
approach, this simplifies the delay based congestion control.<a href="#section-7-2.2.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-7-2.3">
          <p id="section-7-2.3.1">The fast increase mode is removed. The reference window additive increase is
replaced with an adaptive multiplicative increase to enhance convergence
speed.<a href="#section-7-2.3.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-7-2.4">
          <p id="section-7-2.4.1">The algorithm is more rate based than self-clocked. The calculated reference
window is used mainly to calculate proper media bitrates. Bytes in flight is
however allowed to exceeed the reference window.<a href="#section-7-2.4.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-7-2.5">
          <p id="section-7-2.5.1">The media bitrate calculation is dramatically changed and simplified. In practive
it is manifested with a relatively simple relation between the reference window and RTT.<a href="#section-7-2.5.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-7-2.6">
          <p id="section-7-2.6.1">Additional compensation is added to make SCReAMv2 handle cases such as large
changing frame sizes.<a href="#section-7-2.6.1" class="pilcrow">¶</a></p>
</li>
      </ul>
<p id="section-7-3">Algorithm changes since the last draft version -01 are:<a href="#section-7-3" class="pilcrow">¶</a></p>
<ul class="normal">
<li class="normal" id="section-7-4.1">
          <p id="section-7-4.1.1">Slow down reference window growth when close the last know max is disabled
when L4S active. This makes SCReAM adhere more closely to 2 marked packets
per RTT at steady state.<a href="#section-7-4.1.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-7-4.2">
          <p id="section-7-4.2.1">Reference window decrease and increase reduced by up to 50% when ref_wnd/mss
is small. This reduces rate oscillations.<a href="#section-7-4.2.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-7-4.3">
          <p id="section-7-4.3.1">Target bitrate down adjustment when ref_wnd/mss is small is modified to only
help to avoid that the data unit queue grows excessively in certain low
bitrate cases.<a href="#section-7-4.3.1" class="pilcrow">¶</a></p>
</li>
        <li class="normal" id="section-7-4.4">
          <p id="section-7-4.4.1">Timing set to multiples of RTTs instead of seconds.<a href="#section-7-4.4.1" class="pilcrow">¶</a></p>
</li>
      </ul>
</section>
</div>
<div id="iana">
<section id="section-8">
      <h2 id="name-iana-considerations">
<a href="#section-8" class="section-number selfRef">8. </a><a href="#name-iana-considerations" class="section-name selfRef">IANA Considerations</a>
      </h2>
<p id="section-8-1">This document does not require any IANA actions.<a href="#section-8-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="security-considerations">
<section id="section-9">
      <h2 id="name-security-considerations">
<a href="#section-9" class="section-number selfRef">9. </a><a href="#name-security-considerations" class="section-name selfRef">Security Considerations</a>
      </h2>
<p id="section-9-1">The feedback can be vulnerable to attacks similar to those that can affect
TCP. It is therefore RECOMMENDED that the RTCP feedback is at least integrity
protected. Furthermore, as SCReAM/SCReAMv2 is self-clocked, a malicious
middlebox can drop RTCP feedback packets and thus cause the self-clocking to
stall. However, this attack is mitigated by the minimum send rate maintained by
SCReAM/SCReAMv2 when no feedback is received.<a href="#section-9-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="sec-combined-references">
<section id="section-10">
      <h2 id="name-references">
<a href="#section-10" class="section-number selfRef">10. </a><a href="#name-references" class="section-name selfRef">References</a>
      </h2>
<div id="sec-normative-references">
<section id="section-10.1">
        <h3 id="name-normative-references">
<a href="#section-10.1" class="section-number selfRef">10.1. </a><a href="#name-normative-references" class="section-name selfRef">Normative References</a>
        </h3>
<dl class="references">
<dt id="RFC3168">[RFC3168]</dt>
        <dd>
<span class="refAuthor">Ramakrishnan, K.</span>, <span class="refAuthor">Floyd, S.</span>, and <span class="refAuthor">D. Black</span>, <span class="refTitle">"The Addition of Explicit Congestion Notification (ECN) to IP"</span>, <span class="seriesInfo">RFC 3168</span>, <span class="seriesInfo">DOI 10.17487/RFC3168</span>, <time datetime="2001-09" class="refDate">September 2001</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc3168">https://www.rfc-editor.org/info/rfc3168</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC3550">[RFC3550]</dt>
        <dd>
<span class="refAuthor">Schulzrinne, H.</span>, <span class="refAuthor">Casner, S.</span>, <span class="refAuthor">Frederick, R.</span>, and <span class="refAuthor">V. Jacobson</span>, <span class="refTitle">"RTP: A Transport Protocol for Real-Time Applications"</span>, <span class="seriesInfo">STD 64</span>, <span class="seriesInfo">RFC 3550</span>, <span class="seriesInfo">DOI 10.17487/RFC3550</span>, <time datetime="2003-07" class="refDate">July 2003</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc3550">https://www.rfc-editor.org/info/rfc3550</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC4585">[RFC4585]</dt>
        <dd>
<span class="refAuthor">Ott, J.</span>, <span class="refAuthor">Wenger, S.</span>, <span class="refAuthor">Sato, N.</span>, <span class="refAuthor">Burmeister, C.</span>, and <span class="refAuthor">J. Rey</span>, <span class="refTitle">"Extended RTP Profile for Real-time Transport Control Protocol (RTCP)-Based Feedback (RTP/AVPF)"</span>, <span class="seriesInfo">RFC 4585</span>, <span class="seriesInfo">DOI 10.17487/RFC4585</span>, <time datetime="2006-07" class="refDate">July 2006</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc4585">https://www.rfc-editor.org/info/rfc4585</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC5506">[RFC5506]</dt>
        <dd>
<span class="refAuthor">Johansson, I.</span> and <span class="refAuthor">M. Westerlund</span>, <span class="refTitle">"Support for Reduced-Size Real-Time Transport Control Protocol (RTCP): Opportunities and Consequences"</span>, <span class="seriesInfo">RFC 5506</span>, <span class="seriesInfo">DOI 10.17487/RFC5506</span>, <time datetime="2009-04" class="refDate">April 2009</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc5506">https://www.rfc-editor.org/info/rfc5506</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC6298">[RFC6298]</dt>
        <dd>
<span class="refAuthor">Paxson, V.</span>, <span class="refAuthor">Allman, M.</span>, <span class="refAuthor">Chu, J.</span>, and <span class="refAuthor">M. Sargent</span>, <span class="refTitle">"Computing TCP's Retransmission Timer"</span>, <span class="seriesInfo">RFC 6298</span>, <span class="seriesInfo">DOI 10.17487/RFC6298</span>, <time datetime="2011-06" class="refDate">June 2011</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6298">https://www.rfc-editor.org/info/rfc6298</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC6817">[RFC6817]</dt>
        <dd>
<span class="refAuthor">Shalunov, S.</span>, <span class="refAuthor">Hazel, G.</span>, <span class="refAuthor">Iyengar, J.</span>, and <span class="refAuthor">M. Kuehlewind</span>, <span class="refTitle">"Low Extra Delay Background Transport (LEDBAT)"</span>, <span class="seriesInfo">RFC 6817</span>, <span class="seriesInfo">DOI 10.17487/RFC6817</span>, <time datetime="2012-12" class="refDate">December 2012</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc6817">https://www.rfc-editor.org/info/rfc6817</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8174">[RFC8174]</dt>
        <dd>
<span class="refAuthor">Leiba, B.</span>, <span class="refTitle">"Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words"</span>, <span class="seriesInfo">BCP 14</span>, <span class="seriesInfo">RFC 8174</span>, <span class="seriesInfo">DOI 10.17487/RFC8174</span>, <time datetime="2017-05" class="refDate">May 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8174">https://www.rfc-editor.org/info/rfc8174</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC9330">[RFC9330]</dt>
      <dd>
<span class="refAuthor">Briscoe, B., Ed.</span>, <span class="refAuthor">De Schepper, K.</span>, <span class="refAuthor">Bagnulo, M.</span>, and <span class="refAuthor">G. White</span>, <span class="refTitle">"Low Latency, Low Loss, and Scalable Throughput (L4S) Internet Service: Architecture"</span>, <span class="seriesInfo">RFC 9330</span>, <span class="seriesInfo">DOI 10.17487/RFC9330</span>, <time datetime="2023-01" class="refDate">January 2023</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc9330">https://www.rfc-editor.org/info/rfc9330</a>&gt;</span>. </dd>
<dd class="break"></dd>
</dl>
</section>
</div>
<div id="sec-informative-references">
<section id="section-10.2">
        <h3 id="name-informative-references">
<a href="#section-10.2" class="section-number selfRef">10.2. </a><a href="#name-informative-references" class="section-name selfRef">Informative References</a>
        </h3>
<dl class="references">
<dt id="RFC2119">[RFC2119]</dt>
        <dd>
<span class="refAuthor">Bradner, S.</span>, <span class="refTitle">"Key words for use in RFCs to Indicate Requirement Levels"</span>, <span class="seriesInfo">BCP 14</span>, <span class="seriesInfo">RFC 2119</span>, <span class="seriesInfo">DOI 10.17487/RFC2119</span>, <time datetime="1997-03" class="refDate">March 1997</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc2119">https://www.rfc-editor.org/info/rfc2119</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC7478">[RFC7478]</dt>
        <dd>
<span class="refAuthor">Holmberg, C.</span>, <span class="refAuthor">Hakansson, S.</span>, and <span class="refAuthor">G. Eriksson</span>, <span class="refTitle">"Web Real-Time Communication Use Cases and Requirements"</span>, <span class="seriesInfo">RFC 7478</span>, <span class="seriesInfo">DOI 10.17487/RFC7478</span>, <time datetime="2015-03" class="refDate">March 2015</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc7478">https://www.rfc-editor.org/info/rfc7478</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8298">[RFC8298]</dt>
        <dd>
<span class="refAuthor">Johansson, I.</span> and <span class="refAuthor">Z. Sarker</span>, <span class="refTitle">"Self-Clocked Rate Adaptation for Multimedia"</span>, <span class="seriesInfo">RFC 8298</span>, <span class="seriesInfo">DOI 10.17487/RFC8298</span>, <time datetime="2017-12" class="refDate">December 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8298">https://www.rfc-editor.org/info/rfc8298</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8511">[RFC8511]</dt>
        <dd>
<span class="refAuthor">Khademi, N.</span>, <span class="refAuthor">Welzl, M.</span>, <span class="refAuthor">Armitage, G.</span>, and <span class="refAuthor">G. Fairhurst</span>, <span class="refTitle">"TCP Alternative Backoff with ECN (ABE)"</span>, <span class="seriesInfo">RFC 8511</span>, <span class="seriesInfo">DOI 10.17487/RFC8511</span>, <time datetime="2018-12" class="refDate">December 2018</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8511">https://www.rfc-editor.org/info/rfc8511</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8699">[RFC8699]</dt>
        <dd>
<span class="refAuthor">Islam, S.</span>, <span class="refAuthor">Welzl, M.</span>, and <span class="refAuthor">S. Gjessing</span>, <span class="refTitle">"Coupled Congestion Control for RTP Media"</span>, <span class="seriesInfo">RFC 8699</span>, <span class="seriesInfo">DOI 10.17487/RFC8699</span>, <time datetime="2020-01" class="refDate">January 2020</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8699">https://www.rfc-editor.org/info/rfc8699</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8869">[RFC8869]</dt>
        <dd>
<span class="refAuthor">Sarker, Z.</span>, <span class="refAuthor">Zhu, X.</span>, and <span class="refAuthor">J. Fu</span>, <span class="refTitle">"Evaluation Test Cases for Interactive Real-Time Media over Wireless Networks"</span>, <span class="seriesInfo">RFC 8869</span>, <span class="seriesInfo">DOI 10.17487/RFC8869</span>, <time datetime="2021-01" class="refDate">January 2021</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8869">https://www.rfc-editor.org/info/rfc8869</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8985">[RFC8985]</dt>
        <dd>
<span class="refAuthor">Cheng, Y.</span>, <span class="refAuthor">Cardwell, N.</span>, <span class="refAuthor">Dukkipati, N.</span>, and <span class="refAuthor">P. Jha</span>, <span class="refTitle">"The RACK-TLP Loss Detection Algorithm for TCP"</span>, <span class="seriesInfo">RFC 8985</span>, <span class="seriesInfo">DOI 10.17487/RFC8985</span>, <time datetime="2021-02" class="refDate">February 2021</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8985">https://www.rfc-editor.org/info/rfc8985</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8257">[RFC8257]</dt>
        <dd>
<span class="refAuthor">Bensley, S.</span>, <span class="refAuthor">Thaler, D.</span>, <span class="refAuthor">Balasubramanian, P.</span>, <span class="refAuthor">Eggert, L.</span>, and <span class="refAuthor">G. Judd</span>, <span class="refTitle">"Data Center TCP (DCTCP): TCP Congestion Control for Data Centers"</span>, <span class="seriesInfo">RFC 8257</span>, <span class="seriesInfo">DOI 10.17487/RFC8257</span>, <time datetime="2017-10" class="refDate">October 2017</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8257">https://www.rfc-editor.org/info/rfc8257</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC8888">[RFC8888]</dt>
        <dd>
<span class="refAuthor">Sarker, Z.</span>, <span class="refAuthor">Perkins, C.</span>, <span class="refAuthor">Singh, V.</span>, and <span class="refAuthor">M. Ramalho</span>, <span class="refTitle">"RTP Control Protocol (RTCP) Feedback for Congestion Control"</span>, <span class="seriesInfo">RFC 8888</span>, <span class="seriesInfo">DOI 10.17487/RFC8888</span>, <time datetime="2021-01" class="refDate">January 2021</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc8888">https://www.rfc-editor.org/info/rfc8888</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC9000">[RFC9000]</dt>
        <dd>
<span class="refAuthor">Iyengar, J., Ed.</span> and <span class="refAuthor">M. Thomson, Ed.</span>, <span class="refTitle">"QUIC: A UDP-Based Multiplexed and Secure Transport"</span>, <span class="seriesInfo">RFC 9000</span>, <span class="seriesInfo">DOI 10.17487/RFC9000</span>, <time datetime="2021-05" class="refDate">May 2021</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc9000">https://www.rfc-editor.org/info/rfc9000</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="RFC9332">[RFC9332]</dt>
        <dd>
<span class="refAuthor">De Schepper, K.</span>, <span class="refAuthor">Briscoe, B., Ed.</span>, and <span class="refAuthor">G. White</span>, <span class="refTitle">"Dual-Queue Coupled Active Queue Management (AQM) for Low Latency, Low Loss, and Scalable Throughput (L4S)"</span>, <span class="seriesInfo">RFC 9332</span>, <span class="seriesInfo">DOI 10.17487/RFC9332</span>, <time datetime="2023-01" class="refDate">January 2023</time>, <span>&lt;<a href="https://www.rfc-editor.org/info/rfc9332">https://www.rfc-editor.org/info/rfc9332</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="Packet-conservation">[Packet-conservation]</dt>
        <dd>
<span class="refAuthor">Jacobson, V.</span>, <span class="refTitle">"Congestion Avoidance and Control"</span>, <span class="refContent">ACM SIGCOMM Computer Communication Review</span>, <span class="seriesInfo">DOI 10.1145/52325.52356</span>, <time datetime="1988-08" class="refDate">August 1988</time>, <span>&lt;<a href="https://doi.org/10.1145/52325.52356">https://doi.org/10.1145/52325.52356</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="LEDBAT-delay-impact">[LEDBAT-delay-impact]</dt>
        <dd>
<span class="refAuthor">Ros, D.</span> and <span class="refAuthor">M. Welzl</span>, <span class="refTitle">"Assessing LEDBAT's Delay Impact"</span>, <span class="refContent">IEEE Communications Letters, Vol. 17, No. 5,</span>, <span class="seriesInfo">DOI 10.1109/LCOMM.2013.040213.130137</span>, <time datetime="2013-05" class="refDate">May 2013</time>, <span>&lt;<a href="http://home.ifi.uio.no/michawe/research/publications/ledbat-impact-letters.pdf">http://home.ifi.uio.no/michawe/research/publications/ledbat-impact-letters.pdf</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="QoS-3GPP">[QoS-3GPP]</dt>
        <dd>
<span class="refTitle">"Policy and charging control architecture"</span>, <span class="refContent">3GPP TS 23.203</span>, <time datetime="2017-07" class="refDate">July 2017</time>, <span>&lt;<a href="http://www.3gpp.org/ftp/specs/archive/23_series/23.203/">http://www.3gpp.org/ftp/specs/archive/23_series/23.203/</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="SCReAM-CPP-implementation">[SCReAM-CPP-implementation]</dt>
        <dd>
<span class="refAuthor">Ericsson Research</span>, <span class="refTitle">"SCReAM - Mobile optimised congestion control algorithm"</span>, <span>n.d.</span>, <span>&lt;<a href="https://github.com/EricssonResearch/scream">https://github.com/EricssonResearch/scream</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="SCReAM-evaluation-L4S">[SCReAM-evaluation-L4S]</dt>
        <dd>
<span class="refAuthor">Ericsson Research</span>, <span class="refTitle">"SCReAM - evaluations with L4S"</span>, <span>n.d.</span>, <span>&lt;<a href="https://github.com/EricssonResearch/scream/blob/master/L4S-Results.pdf?raw=true">https://github.com/EricssonResearch/scream/blob/master/L4S-Results.pdf?raw=true</a>&gt;</span>. </dd>
<dd class="break"></dd>
<dt id="TFWC">[TFWC]</dt>
      <dd>
<span class="refAuthor">Choi, S.</span> and <span class="refAuthor">M. Handley</span>, <span class="refTitle">"Fairer TCP-Friendly Congestion Control Protocol for Multimedia Streaming Applications"</span>, <span class="seriesInfo">DOI 10.1145/1364654.1364717</span>, <time datetime="2007-12" class="refDate">December 2007</time>, <span>&lt;<a href="http://www-dept.cs.ucl.ac.uk/staff/M.Handley/papers/tfwc-conext.pdf">http://www-dept.cs.ucl.ac.uk/staff/M.Handley/papers/tfwc-conext.pdf</a>&gt;</span>. </dd>
<dd class="break"></dd>
</dl>
</section>
</div>
</section>
</div>
<div id="acknowledgements">
<section id="appendix-A">
      <h2 id="name-acknowledgments">
<a href="#appendix-A" class="section-number selfRef">Appendix A. </a><a href="#name-acknowledgments" class="section-name selfRef">Acknowledgments</a>
      </h2>
<p id="appendix-A-1">Zaheduzzaman Sarker was a co-author of RFC 8298 the previous version
of scream which this document was based on. We would like to thank the
following people for their comments, questions, and support during the
work that led to this memo: Mirja Kuehlewind.<a href="#appendix-A-1" class="pilcrow">¶</a></p>
</section>
</div>
<div id="authors-addresses">
<section id="appendix-B">
      <h2 id="name-authors-addresses">
<a href="#name-authors-addresses" class="section-name selfRef">Authors' Addresses</a>
      </h2>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Ingemar Johansson</span></div>
<div dir="auto" class="left"><span class="org">Ericsson</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:ingemar.s.johansson@ericsson.com" class="email">ingemar.s.johansson@ericsson.com</a>
</div>
</address>
<address class="vcard">
        <div dir="auto" class="left"><span class="fn nameRole">Magnus Westerlund</span></div>
<div dir="auto" class="left"><span class="org">Ericsson</span></div>
<div class="email">
<span>Email:</span>
<a href="mailto:magnus.westerlund@ericsson.com" class="email">magnus.westerlund@ericsson.com</a>
</div>
</address>
</section>
</div>
<script>const toc = document.getElementById("toc");
toc.querySelector("h2").addEventListener("click", e => {
  toc.classList.toggle("active");
});
toc.querySelector("nav").addEventListener("click", e => {
  toc.classList.remove("active");
});
</script>
</body>
</html>
